{
    "contents" : "\n\n# R scripts for extracting and plotting data stored in Mplus graphic\n# information in GH5 files.  Uses the rhdf5 package for loading the\n# the GH5 file.\n#\n# Version history:\n# 2013-09-13 File Version 3 for Mplus Version 7.3\n# 2014-04-30 Fix for sample and estimated means.\n# 2014-10-07 Fix IRT ICC and IIC functions, turning properties into integers\n# 2014-10-08 Add functions for Discrete survival curves\n# 2014-11-20 Fix estimated probabilities function, turning categories into integers.\n# 2014-11-21 Add legend to plot of estimated probabilities.\n# 2015-03-30 Fix plot for factors\n# 2015-06-01 Fix for case-sensitivity on loop label for mplus.get.loop.estimates.\n#            Fix estimated probablities and sample propotions functions, turning categories into integers\n#                and using model_group_labels instead of generic \"Class\" in legend.\n# 2015-06-09 Add option for mplus.plot.loop to plot multiple labels.\n# 2015-09-09 Fix mplus.get.bayesian.autocorrelation and mplus.plot.bayesian.autocorrelation - dimension\n#            of parameter was incorrect.  Fix mplus.plot.bayesian.distribution for alignment when ndist\n#            is the same as the number of iterations.\n#\n# Written by: Thuy Nguyen\n#             Muthen & Muthen\n#\n# Reference:\n#\n# Bernd Fischer and Gregoire Pau (). rhdf5: HDF5 interface to R. R\n# package version 2.4.0.\n#\n\nif (require(rhdf5,quietly=TRUE)) {\n  print(\"Loaded rhdf5 package\")\n} else {\n  print(\"trying to install rhdf5 from bioconductor.org\")\n  source(\"http://bioconductor.org/biocLite.R\")\n  biocLite(\"rhdf5\")\n  if (require(rhdf5)) {\n    print(\"Loaded missing rhdf5 package \")\n  } else {\n    stop(\"could not install rhdf5\")\n  }\n}\n\n\n\n\n\n\n##########################################################################\n#\n# mplus.clear - clears all mplus-related data from a previous mplus_load\n#\n# arguments: none\n#\n# eg. mplus.clear()\n#\n#mplus.clear <- function() {\n#\tcat(c(\"\\nRemoved the following:\\n\"))\n#\n#\tif (exists(\"matrix_data\",)) {\n#\t    rm(matrix_data, inherits=TRUE)\n#\t\tcat(c(\" - matrix_data\\n\"))\n#\t}\n#\tif (exists(\"process_data\",)) {\n#\t    rm(process_data, inherits=TRUE)\n#\t\tcat(c(\" - process_data\\n\"))\n#\t}\n#\tif (exists(\"class_data\")) {\n#\t    rm(class_data, inherits=TRUE)\n#\t\tcat(c(\" - class_data\\n\"))\n#\t}\n#\tif (exists(\"categorical_data\")) {\n#\t    rm(categorical_data, inherits=TRUE)\n#\t\tcat(c(\" - categorical_data\\n\"))\n#\t}\n#\tif (exists(\"individual_data\")) {\n#\t    rm(individual_data, inherits=TRUE)\n#\t\tcat(c(\" - individual_data\\n\"))\n#\t}\n#\tif (exists(\"means_and_variances_data\")) {\n#\t    rm(means_and_variances_data, inherits=TRUE)\n#\t\tcat(c(\" - means_and_variances_data\\n\"))\n#\t}\n#}\n\n\n##########################################################################\n#\n# mplus.list.processes - list all available processes\n#\n# arguments:\n#    file - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.processes('ex8.1.gh5')\n#\nmplus.list.processes <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"mplus.list.proceses requires series information.\\n\\nUse the SERIES option in Mplus to specify series information.\\n\")\n  }\n\n  cat(c(\"\\nList of process names to use in the following functions:\\n\"))\n  cat(c(\" - mplus.plot.sample_means\\n\"))\n  cat(c(\" - mplus.plot.estimated_means\\n\"))\n  cat(c(\" - mplus.plot.sample_and_estimated_means\\n\"))\n  cat(c(\" - mplus.plot.sample_proportions\\n\"))\n  cat(c(\" - mplus.plot.estimated_probabilities\\n\"))\n\n  cat(c(\" - mplus.get.sample_means\\n\"))\n  cat(c(\" - mplus.get.estimated_means\\n\"))\n  cat(c(\" - mplus.get.sample_proportions\\n\"))\n  cat(c(\" - mplus.get.estimated_probabilities\\n\"))\n\n  cat(c(\"\\nProcesses:\\n\"))\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  allpnames\n}\n\n\n##########################################################################\n#\n# mplus.plot.estimated_means - plot estimated means for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.estimated_means('ex8.1.gh5','process1')\n#\nmplus.plot.estimated_means <-function(file,procstr='process1',ptype='o') {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated means.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n  series_type <- prop[1]\n  if ( ! (series_type == 1 || series_type == 2) ) {\n    cstr <- paste(\"- process does not have estimated means:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the time scores\n  xx <- proc$time_scores\n\n  # set up the array for the estimated means\n  dims <- attr(proc$time_scores,\"dim\")\n  yy <- mplus.get.estimated_means(file,procstr)\n\n  # plot the means\n  cstr <- paste(\"Estimated means for\",procstr)\n  plot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n  symb <- array(c(21,22,23,24,25),c(dims[1]))\n  colors <- rainbow(dims[2])\n  for (i in c(1:dims[2])) {\n    lines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n  }\n\n  ldesc <- array(0,c(dims[2]))\n  lty <- array(0,c(dims[2]))\n  lwd <- array(0,c(dims[2]))\n  lcol <- array(0,c(dims[2]))\n  for (i in c(1:dims[2])) {\n    ldesc[i] <- sprintf(\"Class %d\", i)\n    lty[i] = 1\n    lwd[i] = 2.5\n    lcol[i] <- colors[i]\n  }\n  legend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.estimated_modes - plot estimated modes for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.estimated_modes('ex8.1.gh5','process1')\n#\nmplus.plot.estimated_modes <-function(file,procstr='process1',ptype='o') {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated modes.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n  series_type <- prop[1]\n  if ( ! (series_type == 1 || series_type == 2) ) {\n    cstr <- paste(\"- process does not have estimated modes:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the time scores\n  xx <- proc$time_scores\n\n  # set up the array for the estimated means\n  dims <- attr(proc$time_scores,\"dim\")\n  yy <- mplus.get.estimated_modes(file,procstr)\n\n  # plot the means\n  cstr <- paste(\"Estimated modes for\",procstr)\n  plot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n  symb <- array(c(21,22,23,24,25),c(dims[1]))\n  colors <- rainbow(dims[2])\n  for (i in c(1:dims[2])) {\n    lines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n  }\n\n  ldesc <- array(0,c(dims[2]))\n  lty <- array(0,c(dims[2]))\n  lwd <- array(0,c(dims[2]))\n  lcol <- array(0,c(dims[2]))\n  for (i in c(1:dims[2])) {\n    ldesc[i] <- sprintf(\"Class %d\", i)\n    lty[i] = 1\n    lwd[i] = 2.5\n    lcol[i] <- colors[i]\n  }\n  legend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.estimated_medians - plot estimated medians for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.estimated_medians('ex8.1.gh5','process1')\n#\nmplus.plot.estimated_medians <-function(file,procstr='process1',ptype='o') {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated medians.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n  series_type <- prop[1]\n  if ( ! (series_type == 1 || series_type == 2) ) {\n    cstr <- paste(\"- process does not have estimated medians:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the time scores\n  xx <- proc$time_scores\n\n  # set up the array for the estimated means\n  dims <- attr(proc$time_scores,\"dim\")\n  yy <- mplus.get.estimated_medians(file,procstr)\n\n  # plot the means\n  cstr <- paste(\"Estimated medians for\",procstr)\n  plot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n  symb <- array(c(21,22,23,24,25),c(dims[1]))\n  colors <- rainbow(dims[2])\n  for (i in c(1:dims[2])) {\n    lines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n  }\n\n  ldesc <- array(0,c(dims[2]))\n  lty <- array(0,c(dims[2]))\n  lwd <- array(0,c(dims[2]))\n  lcol <- array(0,c(dims[2]))\n  for (i in c(1:dims[2])) {\n    ldesc[i] <- sprintf(\"Class %d\", i)\n    lty[i] = 1\n    lwd[i] = 2.5\n    lcol[i] <- colors[i]\n  }\n  legend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.sample_means - plot sample means for the quoted process\n#\n# arguments:\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.sample_means('ex6.1.gh5','process1')\n#\nmplus.plot.sample_means <-function(file,procstr='process1',ptype='o') {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample means.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file, cstr2, 'properties')\n\n  series_type <- prop[1]\n\n  if ( ! (series_type == 1) ) {\n    cstr <- paste(\"- process does not have sample means:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the time scores\n  xx <- proc$time_scores\n\n  # set up the array for the estimated means\n  dims <- attr(proc$time_scores,\"dim\")\n  yy <- mplus.get.sample_means(file,procstr)\n\n  # plot the means\n  cstr <- paste(\"Sample means for\",procstr)\n  plot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n  symb <- array(c(21,22,23,24,25),c(dims[1]))\n  colors <- rainbow(dims[2])\n  for (i in c(1:dims[2])) {\n    lines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n  }\n\n  ldesc <- array(0,c(dims[2]))\n  lty <- array(0,c(dims[2]))\n  lwd <- array(0,c(dims[2]))\n  lcol <- array(0,c(dims[2]))\n  for (i in c(1:dims[2])) {\n    ldesc[i] <- sprintf(\"Class %d\", i)\n    lty[i] = 1\n    lwd[i] = 2.5\n    lcol[i] <- colors[i]\n  }\n  legend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.sample_and_estimated_means - plot sample and estimated means for the\n# quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.plot.sample_and_estimated_means('process1')\n#\nmplus.plot.sample_and_estimated_means <-function(file,procstr='process1',ptype='o') {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample and estimated means.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n  if ( ! (series_type == 1) ) {\n    cstr <- paste(\"- process does not have sample means:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the dimensions of the time_scores array and create an array with twice the size of the\n  # first dimension\n  dims <- attr(proc$time_scores,\"dim\")\n  xx <- array(0, c(dims[1],2*dims[2]))\n  yy <- array(0, c(dims[1],2*dims[2]))\n\n  samp <- mplus.get.sample_means(file,procstr)\n  emean <- mplus.get.estimated_means(file,procstr)\n\n  for (i in c(1:dims[1])) {\n    for (j in c(1:dims[2])) {\n      # set the time scores and pick up sample means\n      xx[i,2*j-1] <- proc$time_scores[i,j]\n      yy[i,2*j-1] <- samp[i,j]\n\n      # set the time scores and pick up estimated means\n      xx[i,2*j] <- proc$time_scores[i,j]\n      yy[i,2*j] <- emean[i,j]\n    }\n  }\n\n  # plot the means\n  cstr <- paste(\"Sample and estimated means for\",procstr)\n  plot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n  symb <- array(c(21,22,23,24,25),c(dims[2]))\n  colors <- rainbow(dims[2])\n  for (i in c(1:dims[2])) {\n    lines(xx[,2*i-1],yy[,2*i-1],type=ptype,pch=symb[i],col=colors[i])\n    lines(xx[,2*i],yy[,2*i],type=ptype,pch=symb[i],col=colors[i])\n  }\n\n  ldesc <- array(0,c(2*dims[2]))\n  lty <- array(0,c(2*dims[2]))\n  lwd <- array(0,c(2*dims[2]))\n  lcol <- array(0,c(2*dims[2]))\n  lsymb <- array(0,c(2*dims[2]))\n  for (i in c(1:dims[2])) {\n    ldesc[2*i-1] <- sprintf(\"Sample means, Class %d\", i)\n    lty[2*i-1] = 1\n    lwd[2*i-1] = 2.5\n    lsymb[2*i-1] <- symb[i]\n\n    lcol[2*i] <- colors[i]\n    ldesc[2*i] <- sprintf(\"Estimated means, Class %d\", i)\n    lty[2*i] = 1\n    lwd[2*i] = 2.5\n    lcol[2*i] <- colors[i]\n    lsymb[2*i] <- symb[i]\n  }\n  legend('bottomright',col=lcol,pch=lsymb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.estimated_probabilities - plot estimated probabilities for the\n# quoted process, summing up probabilities of the first to the last category\n# chosen\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\tcat1 - the first category to include\n#\tcat2 - the last category to include\n#\n# eg. mplus.plot.estimated_probabilities('ex8.4.gh5','process1',1,1)\n#\nmplus.plot.estimated_probabilities <- function(file,procstr='process1',cat1=1,cat2=1,ptype='o') {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated probabilities.\\n\")\n  }\n\n  # if cat2 is missing and cat1 is given, then we should assign cat2 to cat1.\n  if (missing(cat2)) {\n    if (!(missing(cat1))) {\n      cat2 <- cat1\n    }\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  # Replace the line below with series of low-level function calls\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n  if ( !(series_type == 3) ) {\n    cstr <- paste(\"- process does not have estimated probabilities:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the time scores\n  xx <- proc$time_scores\n\n  # set up the array for the estimated probabilities\n  dims <- attr(proc$time_scores,\"dim\")\n  yy <- mplus.get.estimated_probabilities(file,procstr,cat1,cat2)\n\n  # plot the probabilities\n  cstr <- paste(\"Estimated probabilities for\",procstr)\n  plot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n',ylim=c(0:1))\n  symb <- array(c(21,22,23,24,25),c(dims[1]))\n  colors <- rainbow(dims[2])\n  for (i in c(1:dims[2])) {\n    lines(xx[,i],yy[,i],type=ptype,pch=symb[i],col=colors[i])\n  }\n\n  glabels <- mplus.get.file.dataset(file,'model_group_labels')\n  glabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", glabels, perl=TRUE)\n\n  ldesc <- array(0,c(dims[2]))\n  lty <- array(0,c(dims[2]))\n  lwd <- array(0,c(dims[2]))\n  lcol <- array(0,c(dims[2]))\n  for (i in c(1:dims[2])) {\n    ldesc[i] <- glabels[i] #sprintf(\"Class %d\", i)\n    lty[i] = 1\n    lwd[i] = 2.5\n    lcol[i] <- colors[i]\n  }\n  legend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.plot.sample_proportions - plot sample proportions for the\n# quoted process, summing up proportions of the first to the last category\n# chosen\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\tcat1 - the first category to include\n#\tcat2 - the last category to include\n#\n# eg. mplus.plot.sample_proportions('ex8.4.gh5','process1',1,1)\n#\nmplus.plot.sample_proportions <-function(file,procstr='process1',cat1=1,cat2=1,ptype='o') {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample proportions.\\n\")\n  }\n\n  # if cat2 is missing and cat1 is given, then we should assign cat2 to cat1.\n  if (missing(cat2)) {\n    if (!(missing(cat1))) {\n      cat2 <- cat1\n    }\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    cat(cstr)\n    return(invisible(cstr))\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n  if ( !(series_type == 3) ) {\n    cstr <- paste(\"- process does not have sample proportions:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the time scores\n  xx <- proc$time_scores\n\n  # set up the array for the sample proportions\n  dims <- attr(proc$time_scores,\"dim\")\n  # dims[1] is the number of time points, dims[2] is the number of classes\n  yy <- mplus.get.sample_proportions(file,procstr,cat1,cat2)\n\n  # plot the proportions\n  cstr <- paste(\"Sample proportions for\",procstr)\n  plot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n',ylim=c(0:1))\n  symb <- array(c(21,22,23,24,25),c(dims[1]))\n  colors <- rainbow(dims[2])\n  for (k in c(1:dims[2])) {\n    lines(xx[,k],yy[,k],type=ptype,pch=symb[k],col=colors[k])\n  }\n\n  glabels <- mplus.get.file.dataset(file,'model_group_labels')\n  glabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", glabels, perl=TRUE)\n\n  ldesc <- array(0,c(dims[2]))\n  lty <- array(0,c(dims[2]))\n  lwd <- array(0,c(dims[2]))\n  lcol <- array(0,c(dims[2]))\n  for (i in c(1:dims[2])) {\n    ldesc[i] <- glabels[i] #sprintf(\"Class %d\", i)\n    lty[i] = 1\n    lwd[i] = 2.5\n    lcol[i] <- colors[i]\n  }\n  legend('bottomright',col=lcol,pch=symb,ldesc,lty=lty,lwd=lwd)\n}\n\n\n##########################################################################\n#\n# mplus.get.estimated_means - plot estimated means for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file, required\n#\tprocstr - the quoted name of a series, not required.  Defaults to 'process1' (the first process)\n#\tclassidx - the class index, not required - 0 for all classes.  Default to 0.\n#\n# eg. mplus.get.estimated_means('ex8.1.gh5','process1',3)\n#\nmplus.get.estimated_means <-function(file,procstr='process1',classidx=0) {\n  if (missing(file)) {\n    stop(\" - name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated means.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  # Replace the line below with series of low-level function calls\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n  if ( ! (series_type == 1 || series_type == 2) ) {\n    cstr <- paste(\"- process does not have estimated means:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # set up the array for the estimated means\n  dims <- attr(proc$time_scores,\"dim\")\n  # if all classes, dimension it by number of classes.  Otherwise, just dimension by 1.\n  if (classidx == 0) {\n    yy <- array(0, c(dims[1],dims[2]))\n  } else {\n    # check that the classidx is within range.\n    if (classidx < 0 || classidx > dims[2]) {\n      cstr <- paste(\"- classidx is out of range, 1 to \",dims[2],\": \",classidx,\"\\n\\n\")\n      stop(cstr)\n    }\n    yy <- array(0, c(dims[1],1))\n  }\n\n  # get the indices of variables in the series\n  var_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n  if (series_type == 1) {\n    mean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/y_estimated_means','variables')\n  } else {\n    mean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/latent_estimated_means','variables')\n  }\n  var_indices <- pmatch(var_names, mean_vars, nomatch=0)\n\n  # type 1 is estimated means for observed variables\n  if (series_type == 1) {\n    if (classidx == 0) {\n      for (i in c(1:dims[2])) {\n        for (j in c(1:dims[1])) {\n          yy[j,i] <- gh5$means_and_variances_data$y_estimated_means$values[var_indices[j],i]\n        }\n      }\n    } else {\n      for (j in c(1:dims[1])) {\n        yy[j,i] <- gh5$means_and_variances_data$y_estimated_means$values[var_indices[j],classidx]\n      }\n    }\n  }\n\n  # type 2 is estimated means for latent variables\n  if (series_type == 2) {\n    if (classidx == 0) {\n      for (i in c(1:dims[2])) {\n        for (j in c(1:dims[1])) {\n          yy[j,i] <- gh5$means_and_variances_data$latent_estimated_means$values[var_indices[j],i]\n        }\n      }\n    } else {\n      for (j in c(1:dims[1])) {\n        yy[j,i] <- gh5$means_and_variances_data$latent_estimated_means$values[var_indices[j],classidx]\n      }\n    }\n  }\n\n  # return the means\n  return(yy)\n}\n\n\n##########################################################################\n#\n# mplus.get.sample_means - return sample means for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file, required\n#\tprocstr - the quoted name of a series, not required.  Defaults to 'process1' (the first process)\n#\tclassidx - the class index, not required - 0 for all classes.  Default to 0.\n#\n# eg. mplus.get.sample_means('ex8.1.gh5','process1',3)\n#\nmplus.get.sample_means <- function(file,procstr='process1',classidx=0) {\n  if (missing(file)) {\n    stop(\"- the name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information.\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample means.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  # Replace the line below with series of low-level function calls\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n\n  if ( ! (series_type == 1) ) {\n    cstr <- paste(\"- process does not have sample means:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the time scores\n  xx <- proc$time_scores\n\n  # set up the array for the estimated means\n  dims <- attr(proc$time_scores,\"dim\")\n  # if all classes, dimension it by number of classes.  Otherwise, just dimension by 1.\n  if (classidx == 0) {\n    yy <- array(0, c(dims[1],dims[2]))\n  } else {\n    # check that the classidx is within range.\n    if (classidx < 0 || classidx > dims[2]) {\n      cstr <- paste(\"- classidx is out of range, 1 to \",dims[2],\": \",classidx,\"\\n\\n\")\n      stop(cstr)\n    }\n    yy <- array(0, c(dims[1],1))\n  }\n\n  # get the indices of variables in the series\n  var_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n  mean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/y_observed_means','variables')\n  var_indices <- pmatch(var_names, mean_vars, nomatch=0)\n\n  # only type 1 has sample means\n  if (classidx == 0) {\n    for (i in c(1:dims[2])) {\n      for (j in c(1:dims[1])) {\n        yy[j,i] <- gh5$means_and_variances_data$y_observed_means$values[var_indices[j],i]\n      }\n    }\n  } else {\n    for (j in c(1:dims[1])) {\n      yy[j,i] <- gh5$means_and_variances_data$y_observed_means$values[var_indices[j],classidx]\n    }\n  }\n\n  # return the means\n  return(yy)\n}\n\n\n##########################################################################\n#\n# mplus.get.estimated_modes - plot estimated modes for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file, required\n#\tprocstr - the quoted name of a series, not required.  Defaults to 'process1' (the first process)\n#\tclassidx - the class index, not required - 0 for all classes.  Default to 0.\n#\n# eg. mplus.get.estimated_modes('ex8.1.gh5','process1',3)\n#\nmplus.get.estimated_modes <-function(file,procstr='process1',classidx=0) {\n  if (missing(file)) {\n    stop(\" - name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated modes.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  # Replace the line below with series of low-level function calls\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n  if ( ! (series_type == 1 || series_type == 2) ) {\n    cstr <- paste(\"- process does not have estimated modes:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # set up the array for the estimated modes\n  dims <- attr(proc$time_scores,\"dim\")\n  # if all classes, dimension it by number of classes.  Otherwise, just dimension by 1.\n  if (classidx == 0) {\n    yy <- array(0, c(dims[1],dims[2]))\n  } else {\n    # check that the classidx is within range.\n    if (classidx < 0 || classidx > dims[2]) {\n      cstr <- paste(\"- classidx is out of range, 1 to \",dims[2],\": \",classidx,\"\\n\\n\")\n      stop(cstr)\n    }\n    yy <- array(0, c(dims[1],1))\n  }\n\n  # get the indices of variables in the series\n  var_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n  if (series_type == 1) {\n    mean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/y_estimated_modes','variables')\n  } else {\n    mean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/e_estimated_modes','variables')\n  }\n  var_indices <- pmatch(var_names, mean_vars, nomatch=0)\n\n  # type 1 is estimated means for observed variables\n  if (series_type == 1) {\n    if (classidx == 0) {\n      for (i in c(1:dims[2])) {\n        for (j in c(1:dims[1])) {\n          yy[j,i] <- gh5$means_and_variances_data$y_estimated_modes$values[var_indices[j],i]\n        }\n      }\n    } else {\n      for (j in c(1:dims[1])) {\n        yy[j,i] <- gh5$means_and_variances_data$y_estimated_modes$values[var_indices[j],classidx]\n      }\n    }\n  }\n\n  # type 2 is estimated means for latent variables\n  if (series_type == 2) {\n    if (classidx == 0) {\n      for (i in c(1:dims[2])) {\n        for (j in c(1:dims[1])) {\n          yy[j,i] <- gh5$means_and_variances_data$e_estimated_modes$values[var_indices[j],i]\n        }\n      }\n    } else {\n      for (j in c(1:dims[1])) {\n        yy[j,i] <- gh5$means_and_variances_data$e_estimated_modes$values[var_indices[j],classidx]\n      }\n    }\n  }\n\n  # return the modes\n  return(yy)\n}\n\n\n\n##########################################################################\n#\n# mplus.get.estimated_medians - plot estimated medians for the quoted process\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file, required\n#\tprocstr - the quoted name of a series, not required.  Defaults to 'process1' (the first process)\n#\tclassidx - the class index, not required - 0 for all classes.  Default to 0.\n#\n# eg. mplus.get.estimated_medians('ex8.1.gh5','process1',3)\n#\nmplus.get.estimated_medians <-function(file,procstr='process1',classidx=0) {\n  if (missing(file)) {\n    stop(\" - name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated medians.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  # Replace the line below with series of low-level function calls\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n  if ( ! (series_type == 1 || series_type == 2) ) {\n    cstr <- paste(\"- process does not have estimated medians:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # set up the array for the estimated medians\n  dims <- attr(proc$time_scores,\"dim\")\n  # if all classes, dimension it by number of classes.  Otherwise, just dimension by 1.\n  if (classidx == 0) {\n    yy <- array(0, c(dims[1],dims[2]))\n  } else {\n    # check that the classidx is within range.\n    if (classidx < 0 || classidx > dims[2]) {\n      cstr <- paste(\"- classidx is out of range, 1 to \",dims[2],\": \",classidx,\"\\n\\n\")\n      stop(cstr)\n    }\n    yy <- array(0, c(dims[1],1))\n  }\n\n  # get the indices of variables in the series\n  var_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n  if (series_type == 1) {\n    mean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/y_estimated_medians','variables')\n  } else {\n    mean_vars <- mplus.get.group.attribute(file,'means_and_variances_data/e_estimated_medians','variables')\n  }\n  var_indices <- pmatch(var_names, mean_vars, nomatch=0)\n\n  # type 1 is estimated means for observed variables\n  if (series_type == 1) {\n    if (classidx == 0) {\n      for (i in c(1:dims[2])) {\n        for (j in c(1:dims[1])) {\n          yy[j,i] <- gh5$means_and_variances_data$y_estimated_medians$values[var_indices[j],i]\n        }\n      }\n    } else {\n      for (j in c(1:dims[1])) {\n        yy[j,i] <- gh5$means_and_variances_data$y_estimated_medians$values[var_indices[j],classidx]\n      }\n    }\n  }\n\n  # type 2 is estimated means for latent variables\n  if (series_type == 2) {\n    if (classidx == 0) {\n      for (i in c(1:dims[2])) {\n        for (j in c(1:dims[1])) {\n          yy[j,i] <- gh5$means_and_variances_data$e_estimated_medians$values[var_indices[j],i]\n        }\n      }\n    } else {\n      for (j in c(1:dims[1])) {\n        yy[j,i] <- gh5$means_and_variances_data$e_estimated_medians$values[var_indices[j],classidx]\n      }\n    }\n  }\n\n  # return the modes\n  return(yy)\n}\n\n\n\n##########################################################################\n#\n# mplus.get.time_scores - return time scores for the quoted process\n#\n# arguments:\n#\tprocstr - the quoted name of a series\n#\n# eg. mplus.get.time_scores('ex6.1.gh5', 'process1')\n#\nmplus.get.time_scores <- function(file,procstr='process1') {\n  if (missing(file)) {\n    stop(\"- the name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information.\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample means.\\n\")\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  # Replace the line below with series of low-level function calls\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n\n  # get the time scores\n  xx <- proc$time_scores\n  return(xx)\n}\n\n\n\n##########################################################################\n#\n# mplus.get.estimated_probabilities - return estimated probabilities for the\n# quoted process, summing up probabilities of the first to the last category\n# chosen\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\tcat1 - the first category to include\n#\tcat2 - the last category to include\n#\n# eg. mplus.get.estimated_probabilities('ex8.4.gh5','process1',1,1)\n#\nmplus.get.estimated_probabilities <- function(file,procstr='process1',cat1=1,cat2=1) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith estimated probabilities.\\n\")\n  }\n\n  # if cat2 is missing and cat1 is given, then we should assign cat2 to cat1.\n  if (missing(cat2)) {\n    if (!(missing(cat1))) {\n      cat2 <- cat1\n    }\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n  if ( !(series_type == 3) ) {\n    cstr <- paste(\"- process does not have estimated probabilities:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # set up the array for the estimated probabilities\n  dims <- attr(proc$time_scores,\"dim\")\n  yy <- array(0, c(dims[1],dims[2]))\n\n  # get indices and names of the variables in the series\n  var_indices <- mplus.get.group.attribute(file,cstr2,'var_indices')\n  var_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n  # get categorical data information then look up the variables in the process\n  # in categorical_data so we can get the number of categories for each variable in the process\n  # this would be achieved by categories[cat_indices[i]] for variable i in the process\n  categories <- mplus.get.group.attribute(file,'categorical_data','categories')\n\n  catvars <- mplus.get.group.attribute(file,'categorical_data','var_names')\n  cat_indices <- pmatch(var_names, catvars, nomatch=0)\n\n  # get the probabilities\n  for (i in c(1:dims[1])) {\n    for (j in c(1:dims[2])) {\n      start_index <- sum(as.integer(categories[1:cat_indices[i]-1]))\n\n      startk <- cat1 + start_index\n      endk <- cat2 + start_index\n      yy[i,j] <- sum(gh5$means_and_variances_data$estimated_probs$values[startk:endk,j])\n    }\n  }\n\n  # return the probabilities\n  return(yy);\n}\n\n\n\n\n##########################################################################\n#\n# mplus.get.sample_proportions - return sample proportions for the\n# quoted process, summing up proportions of the first to the last category\n# chosen\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tprocstr - the quoted name of a series\n#\tcat1 - the first category to include\n#\tcat2 - the last category to include\n#\n# eg. mplus.get.sample_proportions('ex8.4.gh5','process1',1,1)\n#\nmplus.get.sample_proportions <-function(file,procstr='process1',cat1=1,cat2=1) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check that the series exists\n  if (!(\"process_data\" %in% names(gh5))) {\n    stop(\"- requires series information\\n\\nUse the SERIES option in Mplus to specify series information for processes\\nwith sample proportions.\\n\")\n  }\n\n  if (missing(procstr)) {\n    stop(\"- requires the name of a series\\n\\nUse mplus.list.processes() to get the list of series processes.\")\n  }\n\n  # if cat2 is missing and cat1 is given, then we should assign cat2 to cat1.\n  if (missing(cat2)) {\n    if (!(missing(cat1))) {\n      cat2 <- cat1\n    }\n  }\n\n  allpnames <- attr(gh5$process_data,\"names\")\n  pind <- pmatch(procstr, allpnames, nomatch=0)\n  if (pind == 0) {\n    cstr <- paste(\"- process does not exist:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # get the process\n  proc <- gh5$process_data[[procstr]]\n\n  # get the series type in properties\n  cstr2 <- paste(c(\"process_data\"),\"/\",procstr,\"\", sep=\"\")\n  prop <- mplus.get.group.attribute(file,cstr2,'properties')\n\n  series_type <- prop[1]\n  if ( ! (series_type == 3) ) {\n    cstr <- paste(\"- process does not have sample proportions:\",procstr,\"\\n\\n\")\n    stop(cstr)\n  }\n\n  # set up the array for the sample proportions\n  dims <- attr(proc$time_scores,\"dim\")\n  # dims[1] is the number of time points, dims[2] is the number of classes\n  yy <- array(0, c(dims[1],dims[2]))\n\n  # get indices and names of the variables in the series\n  var_indices <- mplus.get.group.attribute(file,cstr2,'var_indices')\n  var_names <- mplus.get.group.attribute(file,cstr2,'var_names')\n\n  # get categorical data information then look up the variables in the process\n  # in categorical_data so we can get the number of categories for each variable in the process\n  # this would be achieved by categories[cat_indices[i]] for variable i in the process\n  categories <- mplus.get.group.attribute(file,'categorical_data','categories')\n  categories <- as.integer(categories)\n\n  catvars <- mplus.get.group.attribute(file,'categorical_data','var_names')\n  cat_indices <- pmatch(var_names, catvars, nomatch=0)\n  cat_indices <- as.integer(cat_indices)\n\n  # get the proportions\n  for (i in c(1:dims[1])) {\n    for (j in c(1:dims[2])) {\n      start_index <- sum(categories[1:cat_indices[i]-1])\n\n      startk <- cat1 + start_index\n      endk <- cat2 + start_index\n      yy[i,j] <- sum(gh5$means_and_variances_data$observed_probs$values[startk:endk,j])\n    }\n  }\n\n  # return the proportions\n  return(yy)\n}\n\n\n\n##########################################################################\n#\n# mplus.list.variables - list the variables in individual data\n#\n# arguments: none\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.variables('ex8.1.gh5')\n#\nmplus.list.variables <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if individual data exists\n  if ( !(\"individual_data\" %in% names(gh5)) ) {\n    stop(\"mplus.list.variables requires individual data.\\n\\nUse TYPE=PLOT1 or TYPE=PLOT3 setting in Mplus to store individual data.\")\n  }\n\n  cat(c(\"\\nList of variable names to use in the following functions:\\n\"))\n  cat(c(\" - mplus.plot.histogram\\n\"))\n  cat(c(\" - mplus.plot.scatterplot\\n\"))\n  cat(c(\" - mplus.get.data\\n\"))\n\n  cat(c(\"\\nVariables:\\n\"))\n\n  # get the variable names from individual_data and lookup the indices\n  var_names <- mplus.get.group.attribute(file, 'individual_data', 'var_names')\n  var_names <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", var_names, perl=TRUE)\n  var_names\n}\n\n\n##########################################################################\n#\n# mplus.get.data - return the individual data for the quoted variable\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tv - name of variable to plot\n#\n# eg. mplus.get.data('ex8.1.gh5','y1')\n#\nmplus.get.data <- function(file,v) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  # check that the series exists\n  gh5 <- h5dump(file, load=TRUE)\n\n  if (!(\"individual_data\" %in% names(gh5))) {\n    stop(\"mplus.get.data requires individual data.\\n\\nUse TYPE=PLOT1 or TYPE=PLOT3 setting in Mplus to store individual data.\")\n  }\n\n  if (missing(v)) {\n    stop(\"mplus.get.data requires the name of a variable.\\n\\nUse mplus.list.variables() to get the list of variable names.\")\n  }\n\n  # variables are stored in uppercase\n  var <- toupper(v)\n\n  # get the variable names from individual_data and lookup the indices\n  var_names <- mplus.get.group.attribute(file, 'individual_data', 'var_names')\n\n  index <- pmatch(var, var_names, nomatch=0)\n\n  if (index == 0) {\n    cstr <- paste(c(\"Unknown variable:\"),var,\"\\n\")\n    stop(cstr)\n  }\n\n  # get the data for the variable\n  xx <- gh5$individual_data$raw_data[index,]\n  xx\n}\n\n\n##########################################################################\n#\n# mplus.plot.scatterplot - plot the scatterplot for the 2 quoted variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\txv - name of variable on the x-axis\n#\tyv - name of variable on the y-axis\n#\n# eg. mplus.plot.scatterplot('ex8.1.gh5','y1','y2')\n#\nmplus.plot.scatterplot <- function(file, xv, yv) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if individual data exists\n  if ( !(\"individual_data\" %in% names(gh5)) ) {\n    stop(\"mplus.plot.scatterplot requires individual data.\\n\\nUse TYPE=PLOT1 or TYPE=PLOT3 setting in Mplus to store individual data\\nfor scatterplots.\")\n  }\n\n  if (missing(xv) || missing(yv)) {\n    stop(\"mplus.plot.scatterplot requires the names of two variables.\\n\\nUse mplus.list.variables() to get the list of variable names.\")\n  }\n\n  # variables are stored in uppercase\n  xvar <- toupper(xv)\n  yvar <- toupper(yv)\n\n  # get the variable names from individual_data and lookup the indices\n  var_names <- mplus.get.group.attribute(file, 'individual_data', 'var_names')\n\n  xindex <- pmatch(xvar, var_names, nomatch=0)\n  yindex <- pmatch(yvar, var_names, nomatch=0)\n\n  if (xindex == 0) {\n    cstr <- paste(c(\"Unknown x-variable:\"),xvar,\"\\n\")\n    stop(cstr)\n  }\n  if (yindex == 0) {\n    cstr <- paste(c(\"Unknown y-variable:\"),yvar,\"\\n\")\n    stop(cstr)\n  }\n\n  # get the data for the 2 variables\n  xx <- mplus.get.data(file,xvar)\n  yy <- mplus.get.data(file,yvar)\n\n  plot(xx,yy,xlab=xvar,ylab=yvar)\n}\n\n\n##########################################################################\n#\n# mplus.plot.histogram - plot the histogram for the quoted variable, using the\n# specified number of bins (the default is 10 bins)\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tv - name of variable to plot\n#\tbins - the number of bins to use\n#\n# eg. mplus.plot.histogram('y1',5)\n#\nmplus.plot.histogram <- function(file,v,bins=10) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if individual data exists\n  if ( !(\"individual_data\" %in% names(gh5)) ) {\n    stop(\"mplus.plot.histogram requires individual data.\\n\\nUse TYPE=PLOT1 or TYPE=PLOT3 setting in Mplus to store individual data\\nfor histograms.\")\n  }\n\n  if (missing(v)) {\n    stop(\"mplus.plot.histogram requires the name of a variable.\\n\\nUse mplus.list.variables() to get the list of variable names.\")\n  }\n\n  # the number of bins should be greater than 0\n  if (bins <= 0) {\n    stop(\"The number of bins should be greater than 0.\")\n  }\n\n  # variables are stored in uppercase\n  var <- toupper(v)\n\n  # get the variable names from individual_data and lookup the indices\n  var_names <- mplus.get.group.attribute(file, 'individual_data', 'var_names')\n\n  index <- pmatch(var, var_names, nomatch=0)\n\n  if (index == 0) {\n    cstr <- paste(c(\"Unknown variable:\"),var,\"\\n\")\n    stop(cstr)\n  }\n\n  xx <- mplus.get.data(file,v)\n  cstr <- paste(c(\"Histogram of\"),var)\n  hist(xx,breaks=seq(min(xx),max(xx),length=bins+1),col=\"red\",main=cstr,xlab=var,right=TRUE)\n}\n\n\n######################################################################################################\n# Functions for BAYESIAN plots\n######################################################################################################\n\n\n#=========================================================================\n#\n# mplus.list.bayesian.parameters - list the parameters in bayesian data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.bayesian.parameters('ex8.1.gh5')\n#\nmplus.list.bayesian.parameters <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"mplus.list.bayesian.parameters requires bayesian data.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  cat(c(\"\\nList of parameters to use in the following functions:\\n\"))\n  cat(c(\" - mplus.plot.bayesian.trace_plots\\n\"))\n\n  cat(c(\"\\nParameters:\\n\"))\n\n  # get the parameter statements from bayesian_data and lookup the indices\n  statements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n  statements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n  nplaus <- length(statements)\n  for (i in c(1:nplaus)) {\n    cstr <- sprintf(\"[%d] %s\", i, statements[i])\n    cat(cstr,sep=\"\\n\")\n  }\n  invisible(statements)\n}\n\n#=========================================================================\n#\n# mplus.get.bayesian.parameter.data - get the bayesian data for the given parameter/chain\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   paramstr - the quoted name of a parameter or the parameter index\n#\tchainnum - the chain number\n#\n# eg. mplus.get.bayesian.parameter.data('ex8.1.gh5','parameter 1',1)\n#\nmplus.get.bayesian.parameter.data <- function(file,paramstr,chainnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (is.character(paramstr)) {\n    statements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n    statements <- tolower(statements)\n    paramstr <- tolower(paramstr)\n    paramidx <- pmatch(paramstr, statements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"Unknown parameter:\"),paramstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # first dimension is the number of parameters\n    # second dimension is the number of iterations\n    # third dimension is the number of chains\n    dims <- attr(gh5$bayesian_data$parameters_autocorr$parameters,\"dim\")\n\n    paramidx <- paramstr\n    if (paramidx < 1 || paramidx > dims[1]) {\n      cstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  xx <- gh5$bayesian_data$parameters_autocorr$parameters[paramidx,,chainnum]\n  xx\n}\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.prior.parameter.data - get the prior data for the given parameter\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - the quoted parameter label or the parameter index\n#\n# eg. mplus.get.bayesian.prior.parameter.data('ex8.1.gh5',1)\n#\nmplus.get.bayesian.prior.parameter.data <- function(file,paramstr) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  # first dimension is the number of parameters\n  # second dimension is the number of priors\n  dims <- attr(gh5$bayesian_data$parameters_autocorr$priors,\"dim\")\n\n  if (is.character(paramstr)) {\n    statements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n    statements <- tolower(statements)\n    paramstr <- tolower(paramstr)\n    paramidx <- pmatch(paramstr, statements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # first dimension is the number of parameters\n    # second dimension is the number of priors\n    dims <- attr(gh5$bayesian_data$parameters_autocorr$priors,\"dim\")\n\n    paramidx <- paramstr\n    if (paramidx < 1 || paramidx > dims[1]) {\n      cstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  xx <- gh5$bayesian_data$parameters_autocorr$priors[,paramidx]\n  xx\n}\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.autocorrelation - get the autocorrelation data for the given parameter\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   paramidx - the quoted parameter label\n#   chainnum - the chain number\n#\n# eg. mplus.get.bayesian.autocorrelation('ex8.1.gh5','parameter 1',1)\n#\nmplus.get.bayesian.autocorrelation <- function(file,paramstr,chainnum=1) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  # first dimension is the number of autocorrelation\n  # second dimension is the number of parameters\n  # third dimension is the number of chains\n  dims <- attr(gh5$bayesian_data$parameters_autocorr$autocorrelation,\"dim\")\n  if (is.character(paramstr)) {\n    statements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n    statements <- tolower(statements)\n    paramstr <- tolower(paramstr)\n    paramidx <- pmatch(paramstr, statements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"Unknown parameter:\"),paramstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    paramidx <- paramstr\n    if (paramidx < 1 || paramidx > dims[2]) {\n      cstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  if (chainnum < 1 && chainnum > dims[3]) {\n    cstr <- paste(\"- invalid chain number: \", chainnum,\"\\n\\nThe chain number must be between 1 and \", dims[3], \".\")\n    stop(cstr)\n  }\n\n  xx <- gh5$bayesian_data$parameters_autocorr$autocorrelation[,paramidx,chainnum]\n  xx\n}\n\n#=========================================================================\n#\n# mplus.plot.bayesian.traceplot - list the parameters in bayesian data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   paramstr - the quoted name of a parameter\n#\n# eg. mplus.plot.bayesian.traceplot('ex8.1.gh5','parameter 1')\n#\nmplus.plot.bayesian.traceplot <- function(file,paramstr) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  # get the dimensions of parameters array\n  # first dimension is the number of parameters\n  # second dimension is the number of iterations\n  # third dimension is the number of chains\n  dims <- attr(gh5$bayesian_data$parameters_autocorr$parameters,\"dim\")\n\n  statements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\n  if (is.character(paramstr)) {\n    lcstatements <- tolower(statements)\n    paramstr <- tolower(paramstr)\n    paramidx <- pmatch(paramstr, lcstatements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    paramidx <- paramstr\n    if (paramidx < 1 || paramidx > dims[1]) {\n      cstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n  label <- statements[paramidx]\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  xx <- array(0, c(dims[2],dims[3]))\n  yy <- array(0, c(dims[2],dims[3]))\n\n  for (i in c(1:dims[3])) {\n    yy[,i] <- mplus.get.bayesian.parameter.data(file, paramidx, i)\n  }\n  for (i in c(1:dims[2])) {\n    xx[i,] <- i\n  }\n\n  colors <- rainbow(dims[3])\n\n\n  ndist <- mplus.get.dataset.attribute(file, 'bayesian_data/parameters_autocorr/parameters', 'ndistribution')\n\n  # plot the traceplot\n  cstr <- paste(\"Trace plot of:\",label)\n  plot(xx,yy,xlab=\"\",ylab=\"\",main=cstr,type='n')\n  for (i in c(1:dims[3])) {\n    lines(xx[,i],yy[,i],col=colors[i])\n  }\n  abline(v=ndist,untf=FALSE,col='red')\n}\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.distribution - plot the histogram for the parameter, using the\n# specified number of bins (the default is 100 bins)\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - the quoted name of the parameter\n#\tbins - the number of bins to use\n#\n# eg. mplus.plot.bayesian.distribution('bayes.gh5','parameter 1',50)\n#\nmplus.plot.bayesian.distribution <- function(file,paramstr,bins=100) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(paramstr)) {\n    stop(\"- requires the parameter label or index.\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  # the number of bins should be greater than 0\n  if (bins <= 0) {\n    stop(\"The number of bins should be greater than 0.\")\n  }\n\n  # get the dimensions of parameters array\n  # first dimension is the number of parameters\n  # second dimension is the number of iterations\n  # third dimension is the number of chains\n  dims <- attr(gh5$bayesian_data$parameters_autocorr$parameters,\"dim\")\n  #print(dims)\n\n  statements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n  statements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n  if (is.character(paramstr)) {\n    lcstatements <- tolower(statements)\n    paramstr <- tolower(paramstr)\n    paramidx <- pmatch(paramstr, lcstatements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    paramidx <- paramstr\n    if (paramidx < 1 || paramidx > dims[1]) {\n      cstr <- paste(\"Parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n  label <- statements[paramidx]\n\n  ndist <- mplus.get.dataset.attribute(file, 'bayesian_data/parameters_autocorr/parameters', 'ndistribution')\n\n  yy <- array(0, c(dims[2],dims[3]))\n  if (ndist == dims[2]) {\n    xx <- array(0, c(dims[2]*dims[3]))\n  } else {\n    xx <- array(0, c((dims[2]-ndist)*dims[3]))\n  }\n\n  for (i in c(1:dims[3])) {\n    yy[,i] <- mplus.get.bayesian.parameter.data(file, paramidx, i)\n  }\n  start <- 0\n  for (i in c(1:dims[3])) {\n    if (ndist == dims[2]) {\n      for (j in c(1:dims[2])) {\n        start <- start + 1\n        #cstr <- paste(start, j, i)\n        #print(cstr)\n        #print(xxc[j,i])\n        xx[start] <- yy[j,i]\n      }\n    } else {\n      for (j in c((ndist+1):dims[2])) {\n        start <- start + 1\n        #cstr <- paste(start, j, i)\n        #print(cstr)\n        #print(xxc[j,i])\n        xx[start] <- yy[j,i]\n      }\n    }\n  }\n\n  cstr <- paste(c(\"Distribution of:\"),label)\n  h <- hist(xx,breaks=seq(min(xx),max(xx),length=bins+1),col=\"red\",main=cstr,xlab='Estimate',ylab='Count')\n\n  xxmode <- h$mids[h$counts == max(h$counts)]\n  xxmean <- mean(xx)\n  xxsd <- sd(xx)\n  xxmedian <- median(xx)\n\n  left <- quantile(xx, 0.025)\n  right <- quantile(xx, 0.975)\n\n  abline(v=xxmode,untf=FALSE,col='green')\n  abline(v=xxmean,untf=FALSE,col='brown')\n  abline(v=xxmedian,untf=FALSE,col='purple')\n  abline(v=left,untf=FALSE,col='blue')\n  abline(v=right,untf=FALSE,col='blue')\n\n  modestr <- sprintf(\"Mode = %0.5f\", xxmode)\n  meanstr <- sprintf(\"Mean = %0.5f, Std Dev = %0.5f\", xxmean, xxsd)\n  medianstr <- sprintf(\"Median = %0.5f\", xxmedian)\n  lowci <- sprintf(\"95%% Lower CI = %0.5f\", left)\n  uppci <- sprintf(\"95%% Upper CI = %0.5f\", right)\n  ldesc <- c(meanstr, medianstr, modestr, lowci, uppci)\n\n  lcol <- c('brown','purple','green','blue','blue')\n  legend(\"topright\",ldesc,col=lcol,lty=c(1,1,1,1,1),lwd=c(2.5,2.5,2.5,2.5,2.5))\n\n  #invisible(xx)\n}\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.prior.distribution - plot the histogram for the parameter, using the\n# specified number of bins (the default is 100 bins)\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - the quoted name of the parameter\n#\tbins - the number of bins to use\n#\n# eg. mplus.plot.bayesian.prior.distribution('bayes.gh5','parameter 1',50)\n#\nmplus.plot.bayesian.prior.distribution <- function(file,paramstr,bins=100) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(paramstr)) {\n    stop(\"- requires the parameter index\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  # the number of bins should be greater than 0\n  if (bins <= 0) {\n    stop(\"- the number of bins should be greater than 0\")\n  }\n\n  statements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n  statements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n  # get the dimensions of parameters array\n  # first dimension is the number of parameters\n  # second dimension is the number of priors\n  dims <- attr(gh5$bayesian_data$parameters_autocorr$priors,\"dim\")\n\n  if (is.character(paramstr)) {\n    lcstatements <- tolower(statements)\n    paramstr <- tolower(paramstr)\n    paramidx <- pmatch(paramstr, lcstatements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    paramidx <- paramstr\n    if (paramidx < 1 || paramidx > dims[1]) {\n      cstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n  plabel <- statements[paramidx]\n\n  xx <- mplus.get.bayesian.prior.parameter.data(file, paramidx)\n\n  if (min(xx) == 999 && max(xx) == 999) {\n    stop(\"- prior distributions for this parameter cannot be displayed because the prior is improper\")\n  } else if (min(xx) == 998 && max(xx) == 998) {\n    stop(\"- prior distributions for this parameter are not available\")\n  }\n\n  cstr <- paste(c(\"Prior distribution of:\"),plabel)\n  h <- hist(xx,breaks=seq(min(xx),max(xx),length=bins+1),col=\"red\",main=cstr,xlab='Estimate',ylab='Count')\n\n  xxmode <- h$mids[h$counts == max(h$counts)]\n  xxmean <- mean(xx)\n  xxsd <- sd(xx)\n  xxmedian <- median(xx)\n\n  left <- quantile(xx, 0.025)\n  right <- quantile(xx, 0.975)\n\n  abline(v=xxmode,untf=FALSE,col='green')\n  abline(v=xxmean,untf=FALSE,col='brown')\n  abline(v=xxmedian,untf=FALSE,col='purple')\n  abline(v=left,untf=FALSE,col='blue')\n  abline(v=right,untf=FALSE,col='blue')\n\n  modestr <- sprintf(\"Mode = %0.5f\", xxmode)\n  meanstr <- sprintf(\"Mean = %0.5f, Std Dev = %0.5f\", xxmean, xxsd)\n  medianstr <- sprintf(\"Median = %0.5f\", xxmedian)\n  lowci <- sprintf(\"95%% Lower CI = %0.5f\", left)\n  uppci <- sprintf(\"95%% Upper CI = %0.5f\", right)\n  ldesc <- c(meanstr, medianstr, modestr, lowci, uppci)\n\n  lcol <- c('brown','purple','green','blue','blue')\n  legend(\"topright\",ldesc,col=lcol,lty=c(1,1,1,1,1),lwd=c(2.5,2.5,2.5,2.5,2.5))\n\n  invisible(xx)\n}\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.autocorrelation - plot the autocorrelation histogram for the parameter\n#\tfor the given chain\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - the quoted name of the parameter\n#\tchainnum - the chain number\n#\n# eg. mplus.plot.bayesian.autocorrelation('bayes.gh5','parameter 1',1)\n#\nmplus.plot.bayesian.autocorrelation <- function(file,paramstr,chainnum=1) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian dat.\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(paramstr)) {\n    stop(\"- requires the parameter label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  # get the dimensions of parameters array\n  # first dimension is the number of autocorrelations\n  # second dimension is the number of parameters\n  # third dimension is the number of chains\n  dims <- attr(gh5$bayesian_data$parameters_autocorr$autocorrelation,\"dim\")\n\n  statements <- mplus.get.group.dataset(file, 'bayesian_data/parameters_autocorr', 'statements')\n\n  if (is.character(paramstr)) {\n    lcstatements <- tolower(statements)\n    paramstr <- tolower(paramstr)\n    paramidx <- pmatch(paramstr, lcstatements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown parameter:\"),paramstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    paramidx <- paramstr\n    if (paramidx < 1 || paramidx > dims[2]) {\n      cstr <- paste(\"- parameter index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n  plabel <- statements[paramidx]\n\n  if (chainnum < 1 && chainnum > dims[3]) {\n    cstr <- paste(\"- invalid chain number: \", chainnum,\"\\n\\nThe chain number must be between 1 and \", dims[3], \".\")\n    stop(cstr)\n  }\n\n  yy <- mplus.get.bayesian.autocorrelation(file,paramidx,chainnum)\n  xx <- as.character(1:dims[1])\n\n  cstr <- paste(c(\"Autocorrelation (chain \"),format(chainnum),c(\"): \"),plabel)\n  barplot(yy,ylim=c(-1,1),names.arg=xx,col='red',main=cstr)\n\n  invisible(xx)\n}\n\n\n#=========================================================================\n#\n# mplus.list.bayesian.predictive.labels - list the parameters in bayesian data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.bayesian.predictive.labels('ex8.1.gh5')\n#\nmplus.list.bayesian.predictive.labels <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  cat(c(\"\\nList of parameters to use in the following functions:\\n\"))\n  cat(c(\" - mplus.plot.bayesian.predictive.scatterplots\\n\"))\n  cat(c(\" - mplus.plot.bayesian.predictive.distribution\\n\"))\n\n  cat(c(\"\\nPredictive labels:\\n\"))\n\n  # get the parameter statements from bayesian_data and lookup the indices\n  statements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n  statements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n  statements\n}\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.observed - get the predictive observed data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.observed('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.observed <- function(file,plabel) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plabel)) {\n    stop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  if (is.character(plabel)) {\n    statements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n    statements <- tolower(statements)\n    plabel <- tolower(plabel)\n    paramidx <- pmatch(plabel, statements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of parameters array\n    # first dimension is the number of ???\n    # second dimension is the number of predictive labels\n    dims <- attr(gh5$bayesian_data$predictive$observed,\"dim\")\n\n    paramidx <- plabel\n    if (paramidx < 1 || paramidx > dims[2]) {\n      cstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  xx <- gh5$bayesian_data$predictive$observed[,paramidx]\n  xx\n}\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.replicated - get the predictive replicated data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.replicated('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.replicated <- function(file,plabel) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plabel)) {\n    stop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  if (is.character(plabel)) {\n    statements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n    statements <- tolower(statements)\n    plabel <- tolower(plabel)\n    paramidx <- pmatch(plabel, statements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of parameters array\n    # first dimension is the number of ???\n    # second dimension is the number of predictive labels\n    dims <- attr(gh5$bayesian_data$predictive$replicated,\"dim\")\n\n    paramidx <- plabel\n    if (paramidx < 1 || paramidx > dims[2]) {\n      cstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  xx <- gh5$bayesian_data$predictive$replicated[,paramidx]\n  xx\n}\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.lowerci - get the predictive lower CI\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.lowerci('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.lowerci <- function(file,plabel) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plabel)) {\n    stop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  if (is.character(plabel)) {\n    statements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n    statements <- tolower(statements)\n    plabel <- tolower(plabel)\n    paramidx <- pmatch(plabel, statements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of parameters array\n    # first dimension is the number of pvalues\n    # second dimension is the number of predictive labels\n    dims <- attr(gh5$bayesian_data$predictive$pvalues,\"dim\")\n\n    paramidx <- plabel\n    if (paramidx < 1 || paramidx > dims[2]) {\n      cstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  gh5$bayesian_data$predictive$pvalues[1,paramidx]\n}\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.upperci - get the predictive upper CI\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.upperci('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.upperci <- function(file,plabel) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plabel)) {\n    stop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  if (is.character(plabel)) {\n    statements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n    statements <- tolower(statements)\n    plabel <- tolower(plabel)\n    paramidx <- pmatch(plabel, statements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of parameters array\n    # first dimension is the number of pvalues\n    # second dimension is the number of predictive labels\n    dims <- attr(gh5$bayesian_data$predictive$pvalues,\"dim\")\n\n    paramidx <- plabel\n    if (paramidx < 1 || paramidx > dims[2]) {\n      cstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  gh5$bayesian_data$predictive$pvalues[2,paramidx]\n}\n\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.pvalue - get the predictive pvalue\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.pvalue('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.pvalue <- function(file,plabel) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plabel)) {\n    stop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  if (is.character(plabel)) {\n    statements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n    statements <- tolower(statements)\n    plabel <- tolower(plabel)\n    paramidx <- pmatch(plabel, statements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of parameters array\n    # first dimension is the number of pvalues\n    # second dimension is the number of predictive labels\n    dims <- attr(gh5$bayesian_data$predictive$pvalues,\"dim\")\n\n    paramidx <- plabel\n    if (paramidx < 1 || paramidx > dims[2]) {\n      cstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  gh5$bayesian_data$predictive$pvalues[3,paramidx]\n}\n\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.predictive.pvalue_type - get the predictive pvalue type\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the quoted name of the parameter\n#\n# eg. mplus.get.bayesian.predictive.pvalue_type('bayes.gh5','parameter 1')\n#\nmplus.get.bayesian.predictive.pvalue_type <- function(file,plabel) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plabel)) {\n    stop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  ptypes <- mplus.get.group.attribute(file,'/bayesian_data/predictive','types')\n\n  if (is.character(plabel)) {\n    statements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n    statements <- tolower(statements)\n    plabel <- tolower(plabel)\n    paramidx <- pmatch(plabel, statements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of parameters array\n    # first dimension is the number of pvalues\n    dims <- attr(ptypes,\"dim\")\n\n    paramidx <- plabel\n    if (paramidx < 1 || paramidx > dims[1]) {\n      cstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  ptypes[paramidx]\n}\n\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.predictive.scatterplot - plot the predictive checking scatterplot\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the predictive label\n#\n# eg. mplus.plot.bayesian.predictive.scatterplot('bayes.gh5','label 1')\n#\nmplus.plot.bayesian.predictive.scatterplot <- function(file,plabel) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plabel)) {\n    stop(\"- requires the predictive label\\n\\nUse mplus.list.bayesian.parameters() to get the list of parameters.\")\n  }\n\n  statements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n  statements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n  dims <- attr(statements,\"dim\")\n\n  if (is.character(plabel)) {\n    lcstatements <- tolower(statements)\n    plabel <- tolower(plabel)\n    paramidx <- pmatch(plabel, lcstatements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    paramidx <- plabel\n    if (paramidx < 1 || paramidx > dims[1]) {\n      cstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  rep <- mplus.get.bayesian.predictive.replicated(file,paramidx)\n  obs <- mplus.get.bayesian.predictive.observed(file,paramidx)\n\n  omin <- min(obs)\n  omax <- max(obs)\n\n  rmin <- min(rep)\n  rmax <- max(rep)\n\n  if (omin < rmin) {\n    rmin <- omin\n  }\n  if (omax > rmax) {\n    rmax <- omax\n  }\n\n  plot(obs,rep,xlab='Observed',ylab='Replicated',xlim=c(rmin,rmax),ylim=c(rmin,rmax))\n  #\tprint(rmin)\n  #\tprint(rmax)\n  xx=c(rmin,rmax)\n  yy=c(rmin,rmax)\n  lines(xx,yy,col='green')\n  #text(50,50,\"test\")\n\n  lowci <- mplus.get.bayesian.predictive.lowerci(file,paramidx)\n  uppci <- mplus.get.bayesian.predictive.upperci(file,paramidx)\n  pval <- mplus.get.bayesian.predictive.pvalue(file,paramidx)\n  ptype <- mplus.get.bayesian.predictive.pvalue_type(file,paramidx)\n\n  if (ptype == -1) {\n    text2 <- \"(Proportion of Points in the Lower Right Half)\";\n  }\n  else if (ptype == 1) {\n    text2 <- \"(Proportion of Points in the Upper Left Half)\";\n  } else {\n    text2 <- \"(Smallest Proportion of Points in the Upper versus Lower Halves)\";\n  }\n\n  #ldesc <- sprintf(\"95%% Confidence Interval for the Difference\\n%0.3f     %0.3f\\nPosterior Predictive P-Value %0.3f\\n%s\",\n  #\t\tlowci, uppci, pval, text2)\n\n  #mtext(ldesc, side=3)\n\n  line1 <- sprintf(\"95%% Confidence Interval for the Difference\")\n  line2 <- sprintf(\"            %0.3f     %0.3f                \", lowci, uppci)\n  line3 <- sprintf(\"\")\n  line4 <- sprintf(\"   Posterior Predictive P-Value %0.3f      \", pval)\n  line5 <- sprintf(\"\")\n  line6 <- text2\n\n  ldesc <- c(line1,line2,line3,line4,line5,line6)\n  legend('topleft',ldesc,xjust=1)\n\n  title(statements[paramidx])\n}\n\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.predictive.distribution - plot the predictive checking distribution\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplabel - the predictive label\n#\tbins - the number of bins, default is 10\n#\n# eg. mplus.plot.bayesian.predictive.distribution('bayes.gh5','label 1')\n#\nmplus.plot.bayesian.predictive.distribution <- function(file,plabel,bins=100) {\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data\\n\\nUse TYPE=PLOT2 setting in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plabel)) {\n    stop(\"- requires the index of the predictive label\\n\\nUse mplus.list.bayesian.predictive.labels() to get the list of parameters.\")\n  }\n\n  statements <- mplus.get.group.attribute(file, 'bayesian_data/predictive', 'labels')\n  statements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n  dims <- attr(statements,\"dim\")\n\n  if (is.character(plabel)) {\n    lcstatements <- tolower(statements)\n    plabel <- tolower(plabel)\n    paramidx <- pmatch(plabel, lcstatements, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown predictive label:\"),plabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    paramidx <- plabel\n    if (paramidx < 1 || paramidx > dims[1]) {\n      cstr <- paste(\"- predictive label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.parameters to see the list of parameters.\\n\")\n      stop(cstr)\n    }\n  }\n\n  rep <- mplus.get.bayesian.predictive.replicated(file,paramidx)\n  obs <- mplus.get.bayesian.predictive.observed(file,paramidx)\n\n  omin <- min(obs)\n  omax <- max(obs)\n\n  rmin <- min(rep)\n  rmax <- max(rep)\n\n  if (omin < rmin) {\n    rmin <- omin\n  }\n  if (omax > rmax) {\n    rmax <- omax\n  }\n\n  npred <- length(rep)\n  vals <- array(c(npred))\n  for (i in c(1:npred)) {\n    vals[i] <- obs[i] - rep[i]\n  }\n  hist(vals,breaks=seq(min(vals),max(vals),length=bins+1),col=\"red\",main=statements[paramidx],xlab='Observed - Replicated',ylab='Count')\n\n  xxmedian <- median(vals)\n  abline(v=xxmedian,untf=FALSE,col='purple')\n\n  #\tprint(rmin)\n  #\tprint(rmax)\n  xx=c(rmin,rmax)\n  yy=c(rmin,rmax)\n  lines(xx,yy,col='green')\n  #text(50,50,\"test\")\n\n  lowci <- mplus.get.bayesian.predictive.lowerci(file,paramidx)\n  uppci <- mplus.get.bayesian.predictive.upperci(file,paramidx)\n  pval <- mplus.get.bayesian.predictive.pvalue(file,paramidx)\n\n  #ldesc <- sprintf(\"95%% Confidence Interval for the Difference\\n%0.3f     %0.3f\\nPosterior Predictive P-Value %0.3f\\n%s\",\n  #\t\tlowci, uppci, pval, text2)\n\n  #mtext(ldesc, side=3)\n\n  line1 <- sprintf(\"95%% Confidence Interval for the Difference\")\n  line2 <- sprintf(\"            %0.3f     %0.3f                \", lowci, uppci)\n  line3 <- sprintf(\"\")\n  line4 <- sprintf(\"   Posterior Predictive P-Value %0.3f      \", pval)\n\n  ldesc <- c(line1,line2,line3,line4)\n  legend('topleft',ldesc,xjust=1)\n}\n\n\n\n#=========================================================================\n#\n# mplus.list.bayesian.plausible.labels - list the plausible labels in bayesian data\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.bayesian.plausible.labels('ex8.1.gh5')\n#\nmplus.list.bayesian.plausible.labels <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"mplus.list.bayesian.plausible.labels requires bayesian data and factor scores.\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n  }\n\n  # check if plausible exists\n  if ( !(\"plausible\" %in% names(gh5$bayesian_data)) ) {\n    stop(\"mplus.list.bayesian.plausible.labels requires bayesian data factor scores.\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n  }\n\n  cat(c(\"\\nList of labels to use in the following functions:\\n\"))\n  cat(c(\" - mplus.plot.bayesian.plausible.distribution\\n\"))\n\n  cat(c(\"\\nPlausible labels:\\n\"))\n\n  # get the parameter statements from bayesian_data and lookup the indices\n  statements <- mplus.get.group.attribute(file, 'bayesian_data/plausible', 'plauslabels')\n  statements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n  nplaus <- length(statements)\n  for (i in c(1:nplaus)) {\n    cstr <- sprintf(\"[%d] %s\", i, statements[i])\n    cat(cstr,sep=\"\\n\")\n  }\n  #\tcat(statements,sep=\"\\n\")\n  invisible(statements)\n}\n\n\n\n#=========================================================================\n#\n# mplus.get.bayesian.plausible.data - get plausible data for the given plausible label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tplauslabel - the plausible label or the index of the plausible label\n#\tobs - the observation index or 0 for overall\n#\n# eg. mplus.get.bayesian.plausible.data('ex8.1.gh5',1,obs)\n#\nmplus.get.bayesian.plausible.data <- function(file,plauslabel,obs=0) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data and factor scores\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n  }\n\n  # check if plausible exists\n  if ( !(\"plausible\" %in% names(gh5$bayesian_data)) ) {\n    stop(\"- requires bayesian data and factor scores\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plauslabel)) {\n    stop(\"- requires the plausible label\\n\\nUse mplus.list.bayesian.plausible.labels() to get the list of plausible labels.\")\n  }\n\n  if (is.character(plauslabel)) {\n    labels <- mplus.get.group.attribute(file,'bayesian_data/plausible','plauslabels')\n    labels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n    labels <- tolower(labels)\n    plauslabel <- tolower(plauslabel)\n    paramidx <- pmatch(plauslabel, labels, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown plausible label:\"),plauslabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of plausible array\n    # first dimension is the number of observations\n    # second dimension is the number of imputations\n    # third dimension is the number of labels\n    dims <- attr(gh5$bayesian_data$plausible$plausible,\"dim\")\n\n    paramidx <- plauslabel\n    if (paramidx < 1 || paramidx > dims[3]) {\n      cstr <- paste(\"- plausible label index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.plausible.labels to see the list of plausible labels.\\n\")\n      stop(cstr)\n    }\n  }\n\n  if (obs == 0) {\n    xx <- array(0, c(dims[1]*dims[2]))\n    start <- 0\n    for (i in c(1:dims[1])) {\n      for (j in c(1:dims[2])) {\n        start <- start + 1\n        xx[start] <- gh5$bayesian_data$plausible$plausible[i,j,paramidx]\n      }\n    }\n  } else {\n    xx <- gh5$bayesian_data$plausible$plausible[obs,,paramidx]\n  }\n  xx\n}\n\n\n\n#=========================================================================\n#\n# mplus.plot.bayesian.plausible.distribution - plot the histogram for the plausible label, using the\n# specified number of bins (the default is 100 bins for overall and 10 for a specific observation)\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tparamstr - name or index of variable to plot\n#\tobs - the observation number or 0\n#\tbins - the number of bins to use\n#\n# eg. mplus.plot.bayesian.plausible.distribution('bayes.gh5',1,0)\n#\nmplus.plot.bayesian.plausible.distribution <- function(file,plauslabel,obs=0,bins=100) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if bayesian data exists\n  if ( !(\"bayesian_data\" %in% names(gh5)) ) {\n    stop(\"- requires bayesian data and factor scores\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n  }\n\n  # check if plausible exists\n  if ( !(\"plausible\" %in% names(gh5$bayesian_data)) ) {\n    stop(\"- requires bayesian data and factor scores\\n\\nUse TYPE=PLOT3 and the FACTORS option in Mplus with a Bayesian analysis.\")\n  }\n\n  if (missing(plauslabel)) {\n    stop(\"- requires the index of the plausible label\\n\\nUse mplus.list.bayesian.plausible.labels() to get the list of plausible labels.\")\n  }\n\n  if (missing(bins)) {\n    if (obs == 0) {\n      bins = 100\n    } else {\n      bins = 10\n    }\n  }\n\n  # the number of bins should be greater than 0\n  if (bins <= 0) {\n    stop(\"- the number of bins should be greater than 0\")\n  }\n\n  labels <- mplus.get.group.attribute(file,'bayesian_data/plausible','plauslabels')\n  labels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n  adim <- attr(labels,'dim')\n\n  if (is.character(plauslabel)) {\n    lclabels <- tolower(labels)\n    plauslabel <- tolower(plauslabel)\n    paramidx <- pmatch(plauslabel, lclabels, nomatch=0)\n\n    if (paramidx == 0) {\n      cstr <- paste(c(\"- unknown plausible label:\"),plauslabel,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    paramidx <- plauslabel\n    if (paramidx < 1 || paramidx > adim[1]) {\n      cstr <- paste(\"- plausible index is out of range: \",paramidx,\"\\n\\nUse mplus.list.bayesian.plausible.labels to see the list of plausible labels.\\n\")\n      stop(cstr)\n    }\n  }\n\n  xx <- mplus.get.bayesian.plausible.data(file,paramidx,obs)\n\n  xxmax <- max(xx)\n  xxmin <- min(xx)\n  #\tprint(xxmax)\n  #\tprint(xxmin)\n\n  if (obs == 0) {\n    cstr <- paste(c(\"Overall distribution of\"),labels[paramidx])\n  } else {\n    cstr <- sprintf(\"Distribution of %s for Individual %d\", labels[paramidx], obs)\n  }\n  h <- hist(xx,breaks=seq(min(xx),max(xx),length=bins+1),col=\"red\",main=cstr,xlab='Estimate',ylab='Count')\n\n  xxmode <- h$mids[h$counts == max(h$counts)]\n  xxmean <- mean(xx)\n  xxsd <- sd(xx)\n  xxmedian <- median(xx)\n\n  left <- quantile(xx, 0.025,type=3)\n  right <- quantile(xx, 0.975,type=3)\n\n  abline(v=xxmode,untf=FALSE,col='green')\n  abline(v=xxmean,untf=FALSE,col='brown')\n  abline(v=xxmedian,untf=FALSE,col='purple')\n  abline(v=left,untf=FALSE,col='blue')\n  abline(v=right,untf=FALSE,col='blue')\n\n  modestr <- sprintf(\"Mode = %0.5f\", xxmode)\n  meanstr <- sprintf(\"Mean = %0.5f, Std Dev = %0.5f\", xxmean, xxsd)\n  medianstr <- sprintf(\"Median = %0.5f\", xxmedian)\n  lowci <- sprintf(\"95%% Lower CI = %0.5f\", left)\n  uppci <- sprintf(\"95%% Upper CI = %0.5f\", right)\n  ldesc <- c(meanstr, medianstr, modestr, lowci, uppci)\n\n  lcol <- c('brown','purple','green','blue','blue')\n  legend(\"topleft\",ldesc,col=lcol,lty=c(1,1,1,1,1),lwd=c(2.5,2.5,2.5,2.5,2.5))\n\n  invisible(xx)\n}\n\n######################################################################################################\n# Functions for LOOP PLOT\n######################################################################################################\n\n#========================================================================\n#\n# mplus.list.loop.labels - list the loop variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.loop.labels('ex8.1.gh5')\n#\nmplus.list.loop.labels <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if loop data exists\n  if ( !(\"loop_data\" %in% names(gh5)) ) {\n    stop(\"mplus.list.loop.labels requires loop data.\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT or use the MOD keyword in MODEL INDIRECT.\")\n  }\n\n  cat(c(\"\\nList of loop labels to use in the following functions:\\n\"))\n  cat(c(\" - mplus.plot.loop\\n\"))\n  cat(c(\" - mplus.get.loop.estimates\\n\"))\n  cat(c(\" - mplus.get.loop.lowerci\\n\"))\n  cat(c(\" - mplus.get.loop.upperci\\n\"))\n  cat(c(\" - mplus.get.loop.xvalues\\n\"))\n\n  cat(c(\"\\nLoop labels:\\n\"))\n\n  # get the parameter statements from loop_data and lookup the indices\n  statements <- mplus.get.group.attribute(file, 'loop_data', 'labels')\n  statements <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", statements, perl=TRUE)\n\n  nplaus <- length(statements)\n  for (i in c(1:nplaus)) {\n    cstr <- sprintf(\"[%d] %s\", i, statements[i])\n    cat(cstr,sep=\"\\n\")\n  }\n  #\tcat(statements,sep=\"\\n\")\n  invisible(statements)\n}\n\n\n\n#========================================================================\n#\n# mplus.get.loop.estimates - get the estimates for the given loop label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tloopstr - the quoted loop label\n#\n# eg. mplus.get.loop.estimates('ex8.1.gh5','indirect')\n#\nmplus.get.loop.estimates <- function(file,loopstr=1) {\n  if (missing(file)) {\n    stop(\"- - name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\" - file does not exist:\",file)\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if loop data exists\n  if ( !(\"loop_data\" %in% names(gh5)) ) {\n    stop(\" - requires loop data\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n  }\n\n  if (missing(loopstr)) {\n    loopstr=1\n  }\n\n  if (is.character(loopstr)) {\n    labels <- mplus.get.group.attribute(file,'loop_data','labels')\n    labels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n    labels <- tolower(labels)\n    loopstr <- tolower(loopstr)\n    loopidx <- pmatch(loopstr, labels, nomatch=0)\n\n    if (loopidx == 0) {\n      cstr <- paste(c(\"- unknown loop label:\"),loopstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of the estimates dataset\n    # first dimension is the number of loop labels\n    # second dimension is the number of x points\n    dims <- attr(gh5$loop_data$estimates,'dim')\n\n    loopidx <- loopstr\n    if (loopidx <= 0 || loopidx > dims[1]) {\n      cstr <- paste(\" - loop index is out of range: \",loopidx,\"\\n\\nUse mplus.list.loop.labels to see the list of loop labels.\\n\")\n      stop(cstr)\n    }\n  }\n\n  gh5$loop_data$estimates[loopidx,]\n}\n\n\n\n#========================================================================\n#\n# mplus.get.loop.lowerci - get the lower CI values for the given loop label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tloopstr - the quoted loop label\n#\n# eg. mplus.get.loop.lowerci('ex8.1.gh5','indirect')\n#\nmplus.get.loop.lowerci <- function(file,loopstr=1) {\n  if (missing(file)) {\n    stop(\"- - name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\" - file does not exist:\",file)\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if loop data exists\n  if ( !(\"loop_data\" %in% names(gh5)) ) {\n    stop(\" - requires loop data\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n  }\n\n  if (missing(loopstr)) {\n    loopstr=1\n  }\n\n  if (is.character(loopstr)) {\n    labels <- mplus.get.group.attribute(file,'loop_data','labels')\n    labels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n    labels <- tolower(labels)\n    loopstr <- tolower(loopstr)\n    loopidx <- pmatch(loopstr, labels, nomatch=0)\n\n    if (loopidx == 0) {\n      cstr <- paste(c(\"- unknown loop label:\"),loopstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of the estimates dataset\n    # first dimension is the number of loop labels\n    # second dimension is the number of x points\n    dims <- attr(gh5$loop_data$estimates,'dim')\n\n    loopidx <- loopstr\n    if (loopidx <= 0 || loopidx > dims[1]) {\n      cstr <- paste(\" - loop index is out of range: \",loopidx,\"\\n\\nUse mplus.list.loop.labels to see the list of loop labels.\\n\")\n      stop(cstr)\n    }\n  }\n\n  gh5$loop_data$lowerci[loopidx,]\n}\n\n\n\n#========================================================================\n#\n# mplus.get.loop.upperci - get the upper CI values for the given loop label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tloopstr - the quoted loop label\n#\n# eg. mplus.get.loop.upperci('ex8.1.gh5','indirect')\n#\nmplus.get.loop.upperci <- function(file,loopstr=1) {\n  if (missing(file)) {\n    stop(\"- - name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\" - file does not exist:\",file)\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if loop data exists\n  if ( !(\"loop_data\" %in% names(gh5)) ) {\n    stop(\" - requires loop data\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n  }\n\n  if (missing(loopstr)) {\n    loopstr=1\n  }\n\n  if (is.character(loopstr)) {\n    labels <- mplus.get.group.attribute(file,'loop_data','labels')\n    labels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n    labels <- tolower(labels)\n    loopstr <- tolower(loopstr)\n    loopidx <- pmatch(loopstr, labels, nomatch=0)\n\n    if (loopidx == 0) {\n      cstr <- paste(c(\"- unknown loop label:\"),loopstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    # get the dimensions of the estimates dataset\n    # first dimension is the number of loop labels\n    # second dimension is the number of x points\n    dims <- attr(gh5$loop_data$estimates,'dim')\n\n    loopidx <- loopstr\n    if (loopidx <= 0 || loopidx > dims[1]) {\n      cstr <- paste(\" - loop index is out of range: \",loopidx,\"\\n\\nUse mplus.list.loop.labels to see the list of loop labels.\\n\")\n      stop(cstr)\n    }\n  }\n\n  gh5$loop_data$upperci[loopidx,]\n}\n\n\n\n#========================================================================\n#\n# mplus.get.loop.xvalues - get the x points for the loop plots\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.get.loop.xvalues('ex8.1.gh5')\n#\nmplus.get.loop.xvalues <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if loop data exists\n  if ( !(\"loop_data\" %in% names(gh5)) ) {\n    stop(\"mplus.get.loop.upperci requires loop data.\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n  }\n\n  gh5$loop_data$xvalues\n}\n\n\n\n#========================================================================\n#\n# mplus.plot.loop - plot the loop label\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tloopvar - the index of the loop label\n#\n# eg. mplus.plot.loop('ex8.1.gh5',1)\n#\nmplus.plot.loop <- function(file,loopstr=1) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if loop data exists\n  if ( !(\"loop_data\" %in% names(gh5)) ) {\n    stop(\"requires loop data.\\n\\nUse TYPE=PLOT2 and the PLOT/LOOP keywords in MODEL CONSTRAINT.\")\n  }\n\n  if (missing(loopstr)) {\n    loopstr=1\n  }\n\n  # get the dimensions of the estimates dataset\n  # first dimension is the number of loop labels\n  # second dimension is the number of x points\n  props <- mplus.get.group.attribute(file,'loop_data','properties')\n\n  # get the parameter statements from loop_data and lookup the indices\n  labels <- mplus.get.group.attribute(file, 'loop_data', 'labels')\n  labels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n  labels <- tolower(labels)\n\n  if (length(loopstr) > 1) {\n    loopindices <- vector()\n    num_loop <- length(loopstr)\n    for (r in c(1:num_loop)) {\n      var <- loopstr[r]\n      if (is.character(var)) {\n        var <- tolower(var)\n        index <- pmatch(var, labels, nomatch=0)\n        if (index == 0) {\n          cstr <- sprintf(\"Unknown indicator:  %s\\n\", var)\n          stop(cstr)\n        }\n        loopindices[r] = index\n      } else {\n        if (var <= 0 || var > props[1]) {\n          cstr <- paste(\"Loop index is out of range: \",var,\"\\n\\nUse mplus.list.loop.labels to see the list of loop labels.\\n\")\n          stop(cstr)\n        }\n        loopindices[r] = var\n      }\n    }\n\n    labels <- mplus.get.group.attribute(file, 'loop_data', 'labels')\n    labels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n\n    loopvar <- mplus.get.group.attribute(file,'loop_data','loop_variable')\n    loopvar <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", loopvar, perl=TRUE)\n\n    xx <- array(0,c(3*num_loop,props[2]))\n    yy <- array(0,c(3*num_loop,props[2]))\n\n    for (r in c(1:num_loop)) {\n      loopidx <- loopindices[r]\n      xx[1*r,] <- mplus.get.loop.xvalues(file)\n      xx[2*r,] <- mplus.get.loop.xvalues(file)\n      xx[3*r,] <- mplus.get.loop.xvalues(file)\n\n      yy[1*r,] <- mplus.get.loop.estimates(file,loopidx)\n      yy[2*r,] <- mplus.get.loop.lowerci(file,loopidx)\n      yy[3*r,] <- mplus.get.loop.upperci(file,loopidx)\n    }\n\n    # plot the loop\n    cstr <- paste(\"Loop plots\")\n    plot(xx,yy,xlab=loopvar,ylab=\"Labels\",main=cstr,type='n')\n\n    colors <- rainbow(num_loop)\n    linetype <- c(1:num_loop)\n    plotchar <- seq(18,18+num_loop,1)\n\n    for (r in c(1:num_loop)) {\n      lines(xx[1*r,],yy[1*r,],col=colors[r], pch=plotchar[r])\n      lines(xx[2*r,],yy[2*r,],type='l',lty=linetype[r], col=colors[r], pch=plotchar[r])\n      lines(xx[3*r,],yy[3*r,],type='l',lty=linetype[r], col=colors[r], pch=plotchar[r])\n    }\n\n    grid(NULL, NULL, lty=6, col='cornsilk2')\n\n    ldesc <- array(0,c(num_loop))\n    lty <- array(0,c(num_loop))\n    lwd <- array(0,c(num_loop))\n    for (i in c(1:num_loop)) {\n      ldesc[i] <- sprintf(\"%s\", labels[i])\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n\n    return(invisible())\n  } else if (is.character(loopstr)) {\n    loopstr <- tolower(loopstr)\n    loopidx <- pmatch(loopstr, labels, nomatch=0)\n\n    if (loopidx == 0) {\n      cstr <- paste(c(\"Unknown loop label:\"),loopstr,\"\\n\")\n      stop(cstr)\n    }\n  } else {\n    if (loopstr <= 0 || loopstr > props[1]) {\n      cstr <- paste(\"Loop index is out of range: \",loopvar,\"\\n\\nUse mplus.list.loop.labels to see the list of loop labels.\\n\")\n      stop(cstr)\n    }\n    loopidx <- loopstr\n  }\n\n  labels <- mplus.get.group.attribute(file, 'loop_data', 'labels')\n  labels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", labels, perl=TRUE)\n\n  loopvar <- mplus.get.group.attribute(file,'loop_data','loop_variable')\n  loopvar <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", loopvar, perl=TRUE)\n\n  xx <- array(0,c(3,props[2]))\n  xx[1,] <- mplus.get.loop.xvalues(file)\n  xx[2,] <- mplus.get.loop.xvalues(file)\n  xx[3,] <- mplus.get.loop.xvalues(file)\n\n  yy <- array(0,c(3,props[2]))\n  yy[1,] <- mplus.get.loop.estimates(file,loopidx)\n  yy[2,] <- mplus.get.loop.lowerci(file,loopidx)\n  yy[3,] <- mplus.get.loop.upperci(file,loopidx)\n\n  # plot the loop\n  cstr <- paste(\"Loop plot for\",labels[loopidx])\n  plot(xx,yy,xlab=loopvar,ylab=labels[loopidx],main=cstr,type='n')\n\n  lines(xx[1,],yy[1,],col='red')\n  lines(xx[2,],yy[2,],col='blue')\n  lines(xx[3,],yy[3,],col='blue')\n\n  #\tabline(v=0,untf=FALSE,col='black')\n  #\tabline(h=0,untf=FALSE,col='black')\n  grid(NULL, NULL, lty=6, col='cornsilk2')\n}\n\n\n\n######################################################################################################\n# Functions for IRT plots\n######################################################################################################\n\n#========================================================================\n# mplus.list.irt.variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.irt.variables('ex7.27.gh5')\n#\nmplus.list.irt.variables <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if irt data exists\n  if ( !(\"irt_data\" %in% names(gh5)) ) {\n    stop(\"IRT data is required.\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  cat(c(\"\\nList of variables to use in the following functions:\\n\"))\n  cat(c(\" - mplus.compute.irt.icc\\n\"))\n  cat(c(\" - mplus.plot.irt.icc\\n\"))\n\n  cat(c(\"\\nVariables for 'uvar' argument:\\n\"))\n\n  ulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n  ulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n\n  nvar <- length(ulabels)\n  for (i in c(1:nvar)) {\n    cstr <- sprintf(\"[%d] %s\", i, ulabels[i])\n    cat(cstr,sep=\"\\n\")\n  }\n  invisible(ulabels)\n}\n\n\n#========================================================================\n# mplus.list.irt.xvariables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.irt.xvariables('ex7.27.gh5')\n#\nmplus.list.irt.xvariables <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if irt data exists\n  if ( !(\"irt_data\" %in% names(gh5)) ) {\n    stop(\"IRT data is required.\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  cat(c(\"\\nList of variables to use in the following functions:\\n\"))\n  cat(c(\" - mplus.compute.irt.icc\\n\"))\n  cat(c(\" - mplus.plot.irt.icc\\n\"))\n\n  cat(c(\"\\nVariables for the 'xvar' argument:\\n\"))\n\n  flabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n  flabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n\n  nvar <- length(flabels)\n  for (i in c(1:nvar)) {\n    cstr <- sprintf(\"[%d] %s\", i, flabels[i])\n    cat(cstr,sep=\"\\n\")\n  }\n  invisible(flabels)\n}\n\n#========================================================================\n# mplus.compute.irt.icc\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (required)\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (required)\n#\tuvar - the indicator variable, can be the variable index or the quoted variable name (required)\n#\tcat - the category number (required)\n#\txvector -> the vector containing x values to use (required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\n# eg. mplus.compute.irt.icc('ex7.27.gh5',1,'F','U1',1,seq(-3,3,0.2))\n#\nmplus.compute.irt.icc <- function(file,group,xvar,uvar,cat,xvector,covariates) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if irt data exists\n  if ( !(\"irt_data\" %in% names(gh5)) ) {\n    stop(\"IRT data is required.\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  #\tproperties[1] - number of factors\n  #\tproperties[2] - number of factors/covariates\n  #\tproperties[3] - number of indicators\n  #\tproperties[4] - number of classes\n  #\tproperties[5] - maximum number of categories\n  props <- mplus.get.group.attribute(file,'irt_data','properties')\n\n  num_fx <- as.integer(props[2])\n  num_r <- as.integer(props[3])\n  max_num_cat <- as.integer(props[5])\n\n  flabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n  flabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n\n  ulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n  ulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n\n  if (missing(xvar)) {\n    stop(\"The x-axis variable (xvar) is required.\")\n  } else {\n    if (is.character(xvar)) {\n      xvar <- toupper(xvar)\n      index <- pmatch(xvar, flabels, nomatch=0)\n      if (index == 0) {\n        cstr <- sprintf(\"Unknown x-variable:  %s\\n\", xvar)\n        stop(cstr)\n      }\n      fidx = index\n    } else {\n      if (xvar <= 0 || xvar > num_fx) {\n        stop(\"The index for the x-variable (xvar) is out of range.\")\n      }\n      fidx = xvar\n    }\n  }\n  if (missing(uvar)) {\n    stop(\"The indicator variable (uvar) is required.\")\n  } else {\n    if (is.character(uvar)) {\n      uvar <- toupper(uvar)\n      index <- pmatch(uvar, ulabels, nomatch=0)\n      if (index == 0) {\n        cstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n        stop(cstr)\n      }\n      ridx = index\n    } else {\n      if (uvar <= 0 || uvar > num_r) {\n        stop(\"The index for the indicator (uvar) is out of range.\")\n      }\n      ridx = uvar\n    }\n  }\n  if (missing(group)) {\n    stop(\"The group index (group) is required.\")\n  } else {\n    if (group <= 0 || group > props[4]) {\n      stop(\"The group index (group) is out of range.\")\n    }\n  }\n  if (missing(xvector)) {\n    stop(\"The vector (xvector) containing values for the x-axis is required.\")\n  }\n  if (missing(covariates)) {\n    means <- mplus.get.group.dataset(file,'irt_data','mean')\n    covariates <- means[,group]\n  } else {\n    if (length(covariates) != num_fx) {\n      cstr <- sprintf(\"The length of the covariates vector should be %d.\\nFound: %d\", num_fx, length(covariates))\n      stop(cstr)\n    }\n  }\n\n  links <- mplus.get.group.attribute(file,'categorical_data','link')\n  shift <- 0.0\n  for (i in c(1:num_fx)) {\n    if (i != fidx) {\n      shift <- shift + covariates[i]*gh5$irt_data$loading[ridx,i,group]\n    }\n  }\n\n  prob <- array(0,c(length(xvector)))\n  for (i in c(1:length(xvector))) {\n    x <- xvector[i]\n    if (cat == 1) {\n      p <- gh5$irt_data$tau[cat,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n      p <- p * gh5$irt_data$scale[ridx,group]\n      prob[i] <- lin(p,links[ridx])\n    } else if (cat == max_num_cat) {\n      p = gh5$irt_data$tau[cat-1,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n      p = p * gh5$irt_data$scale[ridx,group]\n      prob[i] = 1.0 - lin(p,links[ridx])\n    } else {\n      p = gh5$irt_data$tau[cat,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n      p = p * gh5$irt_data$scale[ridx,group]\n\n      p2 = gh5$irt_data$tau[cat-1,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n      p2 = p2 * gh5$irt_data$scale[ridx,group]\n\n      prob[i] = lin(p,links[ridx]) - lin(p2,links[ridx])\n    }\n  }\n\n  prob\n}\n\n\n#========================================================================\n# mplus.compute.irt.iic\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (required)\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (required)\n#\tuvar - the indicator variable, can be the variable index or the quoted variable name (required)\n#\txvector -> the vector containing x values to use (required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\n# eg. mplus.compute.irt.iic('ex7.27.gh5',1,'F','U1',seq(-3,3,0.2))\n#\nmplus.compute.irt.iic <- function(file,group,xvar,uvar,xvector,covariates) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if irt data exists\n  if ( !(\"irt_data\" %in% names(gh5)) ) {\n    stop(\"IRT data is required.\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  #\tproperties[1] - number of factors\n  #\tproperties[2] - number of factors/covariates\n  #\tproperties[3] - number of indicators\n  #\tproperties[4] - number of classes\n  #\tproperties[5] - maximum number of categories\n  props <- mplus.get.group.attribute(file,'irt_data','properties')\n\n  num_fx <- as.integer(props[2])\n  num_r <- as.integer(props[3])\n  max_num_cat <- as.integer(props[5])\n\n  if (missing(xvar)) {\n    stop(\"The x-axis variable (xvar) is required.\")\n  } else {\n    if (is.character(xvar)) {\n      index <- pmatch(xvar, flabels, nomatch=0)\n      if (index == 0) {\n        cstr <- sprintf(\"Unknown x-variable:  %s\\n\", xvar)\n        stop(cstr)\n      }\n      fidx = index\n    } else {\n      if (xvar <= 0 || xvar > num_fx) {\n        stop(\"The index for the x-variable (xvar) is out of range.\")\n      }\n      fidx = xvar\n    }\n  }\n  if (missing(uvar)) {\n    stop(\"The indicator variable (uvar) is required.\")\n  } else {\n    if (is.character(uvar)) {\n      index <- pmatch(uvar, ulabels, nomatch=0)\n      if (index == 0) {\n        cstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n        stop(cstr)\n      }\n      ridx = index\n    } else {\n      if (uvar <= 0 || uvar > num_r) {\n        stop(\"The index for the indicator (uvar) is out of range.\")\n      }\n      ridx = uvar\n    }\n  }\n  if (missing(group)) {\n    stop(\"The group index (group) is required.\")\n  } else {\n    if (group <= 0 || group > props[4]) {\n      stop(\"The group index (group) is out of range.\")\n    }\n  }\n  if (missing(xvector)) {\n    stop(\"The vector (xvector) containing values for the x-axis is required.\")\n  }\n  if (missing(covariates)) {\n    covariates <- mplus.get.group.dataset(file,'irt_data','mean')\n  } else {\n    if (length(covariates) != num_fx) {\n      cstr <- sprintf(\"The length of the covariates vector should be %d.\\nFound: %d\", num_fx, length(covariates))\n      stop(cstr)\n    }\n  }\n\n  categories <- mplus.get.group.attribute(file,'irt_data','categories')\n  links <- mplus.get.group.attribute(file,'categorical_data','link')\n\n  shift <- 0.0\n  for (i in c(1:num_fx)) {\n    if (i != fidx) {\n      shift <- shift + covariates[i]*gh5$irt_data$loading[ridx,i,group]\n    }\n  }\n\n  categories <- as.numeric(categories)\n\n  probvec <- array(0, c(length(xvector),categories[ridx]+1))\n  for (i in c(1:length(xvector))) {\n    x <- xvector[i]\n    probvec[1] <- 0\n    for (j in c(2:c(categories[ridx]))) {\n      fp = gh5$irt_data$tau[j-1,ridx,group] - shift - x * gh5$irt_data$loading[fidx,ridx,group]\n      fp = fp * gh5$irt_data$scale[ridx,group]\n      dp = lin(fp,links[ridx])\n      probvec[i,j] <- dp\n    }\n    probvec[i,categories[ridx]+1]=1.0\n  }\n\n  prob <- array(0,c(length(xvector)))\n  for (i in c(1:length(xvector))) {\n    x <- xvector[i]\n    for (j in c(2:c(categories[ridx]+1))) {\n      r <- 10**(-10)\n      ep = probvec[i,j] - probvec[i,j-1]\n      if (ep < r) { ep <- r }\n      dp = gh5$irt_data$scale[ridx,group] * gh5$irt_data$loading[fidx,ridx,group] * gh5$irt_data$scale[ridx,group] * gh5$irt_data$loading[fidx,ridx,group];\n      p = (probvec[i,j] * (1-probvec[i,j])) - (probvec[i,j-1] * (1-probvec[i,j-1]))\n      prob[i] <- prob[i] + p * p * dp / ep\n    }\n  }\n\n  prob\n}\n\n#========================================================================\n# mplus.plot.irt.icc\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (not required) -- 1 if not specified\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (not required, uses the first x)\n#\tuvar - the indicator variable or vector containing more than one indicator variable\n#\t\t - can be the variable index or the quoted variable name\n#\t\t - if not given, assume all indicator variables but cat must be given (not required)\n#\tcat - the category number\n#\t\t- if not given, assume all categories for the given indicator variables\n#\t\t- required if uvar not given\n#\tcat2 - the second category number if range of categories is desired (not required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\txrange - the type of range for the x-axis (not required)\n#\t\t- xrange=1: -1 s.d to +1 s.d of xvar\n#\t\t- xrange=2: -2 s.d to +2 s.d of xvar\n#\t\t- xrange=3: -3 s.d to +3 s.d of xvar (default)\n#\t\t- xrange=4: -4 s.d to +4 s.d of xvar\n#\t\t- xrange=5: -5 s.d to +5 s.d of xvar\n#\t\t- xrange=6: -6 s.d to +6 s.d of xvar\n#\txstep - the step increment for the x-axis range (not required)\n#\t\t- xstep=1: 1.0\n#\t\t- xstep=2: 0.5\n#\t\t- xstep=3: 0.1\n#\t\t- xstep=4: 0.05\n#\t\t- xstep=5: 1/2 s.d of xvar\n#\t\t- xstep=6: 1/4 s.d of xvar\n#\t\t- xstep=7: 1/5 s.d of xvar (default)\n#\t\t- xstep=8: 1/10 s.d of xvar\n#\t\t- xstep=9: 1/20 s.d of xvar\n#\t\t- xstep=10: 1/50 s.d of xvar\n#\t\t- xstep=11: 1/100 s.d of xvar\n#\n# eg. mplus.plot.irt.icc('ex7.27.gh5',1,'F','U1',)\n#\nmplus.plot.irt.icc <- function(file,group=1,xvar=1,uvar,cat,cat2,covariates,xrange=3,xstep=7,lloc=\"top\") {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if irt data exists\n  if ( !(\"irt_data\" %in% names(gh5)) ) {\n    stop(\"This function requires IRT data.\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  #\tproperties[1] - number of factors\n  #\tproperties[2] - number of factors/covariates\n  #\tproperties[3] - number of indicators\n  #\tproperties[4] - number of classes\n  #\tproperties[5] - maximum number of categories\n  props <- mplus.get.group.attribute(file,'irt_data','properties')\n\n  flabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n  flabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n  ulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n  ulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n\n  num_fx <- as.integer(props[2])\n  num_r <- as.integer(props[3])\n  max_num_cat <- as.integer(props[5])\n\n  if (is.character(xvar)) {\n    xvar <- toupper(xvar)\n    index <- pmatch(xvar, flabels, nomatch=0)\n    if (index == 0) {\n      cstr <- sprintf(\"Unknown variable for the x-axis:  %s\\n\", xvar)\n      stop(cstr)\n    }\n    fidx = index\n  } else {\n    if (xvar <= 0 || xvar > num_fx) {\n      stop(\"The index for the x-variable (xvar) is out of range.\")\n    }\n    fidx = xvar\n  }\n  if (missing(uvar)) {\n  } else if (length(uvar) > 1) {\n    ridx <- vector()\n    for (r in c(1:length(uvar))) {\n      var <- uvar[r]\n      if (is.character(var)) {\n        var <- toupper(var)\n        index <- pmatch(var, ulabels, nomatch=0)\n        if (index == 0) {\n          cstr <- sprintf(\"Unknown indicator:  %s\\n\", var)\n          stop(cstr)\n        }\n        ridx[r] = index\n      } else {\n        if (var <= 0 || var > num_r) {\n          stop(\"The index for the indicator in uvar is out of range.\")\n        }\n        ridx[r] = var\n      }\n    }\n  } else {\n    if (is.character(uvar)) {\n      uvar <- toupper(uvar)\n      index <- pmatch(uvar, ulabels, nomatch=0)\n      if (index == 0) {\n        cstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n        stop(cstr)\n      }\n      ridx <- index\n    } else {\n      if (uvar <= 0 || uvar > num_r) {\n        stop(\"The index for the indicator (uvar) is out of range.\")\n      }\n      ridx <- uvar\n    }\n  }\n  if (group <= 0 || group > props[4]) {\n    stop(\"The group index (group) is out of range.\")\n  }\n  if (missing(covariates)) {\n    xmean <- mplus.get.group.dataset(file,'irt_data','mean')\n    covariates <- xmean[,group]\n  } else {\n    if (length(covariates) != num_fx) {\n      cstr <- sprintf(\"The length of the covariates vector should be %d.\", num_fx)\n      stop(cstr)\n    }\n  }\n\n  categories <- mplus.get.group.attribute(file,'irt_data','categories')\n  if (missing(uvar)) {\n    # case 1: uvar not specified, we plot ICC for all variables.  The category number must be given.\n    if (missing(cat)) {\n      stop(\"The category number (cat) is required when plotting ICCs for all variables.\")\n    }\n    for (i in c(1:num_r)) {\n      if (cat <= 0 || cat > categories[i]) {\n        cstr <- sprintf(\"The category number (cat) is out of range for variable %s.\", ulabels[i])\n        stop(cstr)\n      }\n    }\n    if (!(missing(cat2))) {\n      if (cat > cat2) {\n        cstr <- sprintf(\"The first category number (cat2=%d) must be smaller than the second category number (cat2=%d).\", cat, cat2)\n        stop(cstr)\n      }\n      for (i in c(1:num_r)) {\n        if (cat2 <= 0 || cat2 > categories[i]) {\n          cstr <- sprintf(\"The second category number (cat2) is out of range for variable %s.\", ulabels[i])\n          stop(cstr)\n        }\n      }\n    }\n  } else if (length(uvar) > 1) {\n    for (r in c(1:length(ridx))) {\n      if (!(missing(cat))) {\n        if (cat <= 0 || cat > categories[ridx[r]]) {\n          cstr <- sprintf(\"The category (cat) is out of range for variable %s.\", ulabels[ridx[r]])\n          stop(cstr)\n        }\n      } else {\n        # cat is missing but cat2 isn't!\n        if (!(missing(cat2))) {\n          stop(\"The first category (cat) is required if the second category (cat2) is given.\")\n        }\n      }\n      if (!(missing(cat2))) {\n        if (cat2 <= 0 || cat2 > categories[ridx[r]]) {\n          cstr <- sprintf(\"The category (cat2) is out of range for variable %s.\", ulabels[ridx[r]])\n          stop(cstr)\n        }\n        if (cat > cat2) {\n          cstr <- sprintf(\"The first category (cat2=%d) must be smaller than the second category (cat2=%d).\", cat, cat2)\n          stop(cstr)\n        }\n      }\n    }\n  } else {\n    if (!(missing(cat))) {\n      if (cat <= 0 || cat > categories[ridx]) {\n        cstr <- sprintf(\"The category (cat) is out of range for variable %s.\", ulabels[ridx])\n        stop(cstr)\n      }\n    } else {\n      # cat is missing but cat2 isn't!\n      if (!(missing(cat2))) {\n        stop(\"The first category (cat) is required if the second category (cat2) is given.\")\n      }\n    }\n    if (!(missing(cat2))) {\n      if (cat2 <= 0 || cat2 > categories[ridx]) {\n        cstr <- sprintf(\"The category (cat2) is out of range for variable %s.\", ulabels[ridx])\n        stop(cstr)\n      }\n      if (cat > cat2) {\n        cstr <- sprintf(\"The first category (cat2=%d) must be smaller than the second category (cat2=%d).\", cat, cat2)\n        stop(cstr)\n      }\n    }\n  }\n  if (!(missing(xrange))) {\n    if (xrange <= 0 || xrange > 6) {\n      stop(\"The xrange type should be between 1 and 6.\")\n    }\n  }\n  if (!(missing(xstep))) {\n    if (xstep <= 0 || xstep > 11) {\n      stop(\"The xstep type should be between 1 and 11.\")\n    }\n  }\n\n  variances <- mplus.get.group.dataset(file,'irt_data','variance')\n  means <- mplus.get.group.dataset(file,'irt_data','mean')\n  fsd = sqrt(variances[fidx])\n\n  xmult <- switch(xrange, 1, 2, 3, 4, 5, 6)\n  vmin = means[fidx] + (-1) * xmult * fsd\n  vmax = means[fidx] + xmult * fsd\n\n  vstep = switch(xstep, 1.0, 0.5, 0.1, 0.05, 0.5*fsd, 0.25*fsd, 0.2*fsd, 0.1*fsd, 0.05*fsd, 0.02*fsd, 0.01*fsd)\n  steps <- seq(vmin,vmax,by=vstep)\n\n  print(steps)\n\n  # if cat is missing, then we plot all categories\n  if (missing(uvar)) {\n    prob <- array(0,c(num_r,length(steps)))\n    xx <- array(0,c(num_r,length(steps)))\n    if (missing(cat2)) {\n      for (r in c(1:num_r)) {\n        prob[r,] <- mplus.compute.irt.icc(file,group,fidx,r,cat,xvector=steps,covariates=covariates)\n        xx[r,] <- steps\n      }\n    } else {\n      for (r in c(1:num_r)) {\n        for (c in c(cat:cat2)) {\n          prob[r,] <- prob[r,] + mplus.compute.irt.icc(file,group,fidx,r,c,xvector=steps,covariates=covariates)\n        }\n        xx[r,] <- steps\n      }\n    }\n\n    # plot the icc\n    cstr <- sprintf(\"Item characteristic curves as a function of %s, Class %d\", flabels[fidx], group)\n    colors <- rainbow(num_r)\n    plot(xx,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n')\n    for (i in c(1:num_r)) {\n      lines(xx[i,],prob[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(num_r))\n    lty <- array(0,c(num_r))\n    lwd <- array(0,c(num_r))\n    for (i in c(1:num_r)) {\n      if (missing(cat2)) {\n        ldesc[i] <- sprintf(\"%s, Category %d\", ulabels[i], cat)\n      } else {\n        ldesc[i] <- sprintf(\"%s, Cat %d to %d\", ulabels[i], cat, cat2)\n      }\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(lloc,ldesc,col=colors,lty=lty,lwd=lwd)\n  } else if (length(ridx) > 1) {\n    prob <- array(0,c(length(ridx),length(steps)))\n    xx <- array(0,c(length(ridx),length(steps)))\n    if (missing(cat)) {\n      for (j in c(1:categories[ridx])) {\n        prob[j,] <- mplus.compute.irt.icc(file,group,fidx,ridx,j,xvector=steps,covariates=covariates)\n        xx[j,] <- steps\n      }\n    } else if (missing(cat2)) {\n      for (r in c(1:length(ridx))) {\n        prob[r,] <- mplus.compute.irt.icc(file,group,fidx,ridx[r],cat,xvector=steps,covariates=covariates)\n        xx[r,] <- steps\n      }\n    } else {\n      for (r in c(1:length(ridx))) {\n        for (c in c(cat:cat2)) {\n          prob[r,] <- prob[r,] + mplus.compute.irt.icc(file,group,fidx,ridx[r],c,xvector=steps,covariates=covariates)\n        }\n        xx[r,] <- steps\n      }\n    }\n\n    # plot the icc\n    cstr <- sprintf(\"Item characteristic curves as a function of %s, Class %d\", flabels[fidx], group)\n    colors <- rainbow(length(ridx))\n    plot(xx,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n')\n    for (i in c(1:length(ridx))) {\n      lines(xx[i,],prob[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(length(ridx)))\n    lty <- array(0,c(length(ridx)))\n    lwd <- array(0,c(length(ridx)))\n    for (i in c(1:length(ridx))) {\n      if (missing(cat2)) {\n        ldesc[i] <- sprintf(\"%s, Category %d\", ulabels[ridx[i]], cat)\n      } else {\n        ldesc[i] <- sprintf(\"%s, Cat %d to %d\", ulabels[ridx[i]], cat, cat2)\n      }\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(lloc,ldesc,col=colors,lty=lty,lwd=lwd)\n  } else if (missing(cat)) {\n    prob <- array(0,c(categories[ridx],length(steps)))\n    xx <- array(0,c(categories[ridx],length(steps)))\n    for (j in c(1:categories[ridx])) {\n      prob[j,] <- mplus.compute.irt.icc(file,group,fidx,ridx,j,steps,covariates)\n      xx[j,] <- steps\n    }\n\n    # plot the icc\n    cstr <- sprintf(\"Item characteristic curve for %s (all categories)\\n as a function of %s, Class %d\", ulabels[ridx], flabels[fidx], group)\n    colors <- rainbow(categories[ridx])\n    plot(xx,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n    for (i in c(1:categories[ridx])) {\n      lines(xx[i,],prob[i,],col=colors[i])\n    }\n\n    ldesc <- vector()\n    for (i in c(1:categories[ridx])) {\n      ldesc[i] <- sprintf(\"%s, Category %d\", ulabels[ridx], i)\n    }\n\n    legend(lloc,ldesc,col=colors,lty=c(1,1,1,1,1),lwd=c(2.5,2.5,2.5,2.5,2.5))\n  } else if (missing(cat2)) {\n    # if cat2 is missing, then we plot only the given category\n\n    prob <- mplus.compute.irt.icc(file,group,fidx,ridx,cat,steps,covariates)\n\n    # plot the icc\n    cstr <- sprintf(\"Item characteristic curve for %s (category %d)\\n as a function of %s, Class %d\", ulabels[ridx], cat, flabels[fidx], group)\n    plot(steps,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n    lines(steps,prob,col='red')\n  } else {\n    # if cat and cat2 are given, then we plot the sum from cat to cat2\n\n    prob <- array(0,c(length(steps)))\n    for (c in c(cat:cat2)) {\n      prob <- prob + mplus.compute.irt.icc(file,group,fidx,ridx,c,steps,covariates)\n    }\n\n    # plot the icc\n    cstr <- sprintf(\"Item characteristic curve for %s\\n(sum from category %d to category %d)\\nas a function of %s, Class %d\", ulabels[ridx], cat, cat2, flabels[fidx], group)\n\n    plot(steps,prob,xlab=flabels[fidx],ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n    lines(steps,prob,col='red')\n  }\n\n  steps\n}\n\n\n#========================================================================\n# mplus.plot.irt.iic\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (not required)\n#\t\t - if not given, group=1 will be used\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (not required, uses the first x)\n#\tuvar - the indicator variable or vector containing more than one indicator variable\n#\t\t - can be the variable index or the quoted variable name\n#\t\t - if not given, assume all indicator variables (not required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\txrange - the type of range for the x-axis (not required)\n#\t\t- xrange=1: -1 s.d to +1 s.d of xvar\n#\t\t- xrange=2: -2 s.d to +2 s.d of xvar\n#\t\t- xrange=3: -3 s.d to +3 s.d of xvar (default)\n#\t\t- xrange=4: -4 s.d to +4 s.d of xvar\n#\t\t- xrange=5: -5 s.d to +5 s.d of xvar\n#\t\t- xrange=6: -6 s.d to +6 s.d of xvar\n#\txstep - the step increment for the x-axis range (not required)\n#\t\t- xstep=1: 1.0\n#\t\t- xstep=2: 0.5\n#\t\t- xstep=3: 0.1\n#\t\t- xstep=4: 0.05\n#\t\t- xstep=5: 1/2 s.d of xvar\n#\t\t- xstep=6: 1/4 s.d of xvar\n#\t\t- xstep=7: 1/5 s.d of xvar (default)\n#\t\t- xstep=8: 1/10 s.d of xvar\n#\t\t- xstep=9: 1/20 s.d of xvar\n#\t\t- xstep=10: 1/50 s.d of xvar\n#\t\t- xstep=11: 1/100 s.d of xvar\n#\n# eg. mplus.plot.irt.iic('ex7.27.gh5',1,'F','U1',)\n#\nmplus.plot.irt.iic <- function(file,group=1,xvar=1,uvar,covariates,xrange=3,xstep=7,lloc=\"top\") {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if irt data exists\n  if ( !(\"irt_data\" %in% names(gh5)) ) {\n    stop(\"This function requires IRT data.\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  #\tproperties[1] - number of factors\n  #\tproperties[2] - number of factors/covariates\n  #\tproperties[3] - number of indicators\n  #\tproperties[4] - number of classes\n  #\tproperties[5] - maximum number of categories\n  props <- mplus.get.group.attribute(file,'irt_data','properties')\n\n  flabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n  flabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n  flabels <- tolower(flabels)\n  ulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n  ulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n  ulabels <- tolower(ulabels)\n\n  num_fx <- as.integer(props[2])\n  num_r <- as.integer(props[3])\n  max_num_cat <- as.integer(props[5])\n\n  if (is.character(xvar)) {\n    xvar <- tolower(xvar)\n    index <- pmatch(xvar, flabels, nomatch=0)\n    if (index == 0) {\n      cstr <- sprintf(\"Unknown variable for the x-axis:  %s\\n\", xvar)\n      stop(cstr)\n    }\n    fidx = index\n  } else {\n    if (xvar <= 0 || xvar > num_fx) {\n      stop(\"The index for the x-variable (xvar) is out of range.\")\n    }\n    fidx = xvar\n  }\n  if (missing(uvar)) {\n  } else if (length(uvar) > 1) {\n    ridx <- vector()\n    for (r in c(1:length(uvar))) {\n      var <- uvar[r]\n      if (is.character(var)) {\n        index <- pmatch(var, ulabels, nomatch=0)\n        if (index == 0) {\n          cstr <- sprintf(\"Unknown indicator:  %s\\n\", var)\n          stop(cstr)\n        }\n        ridx[r] = index\n      } else {\n        if (var <= 0 || var > num_r) {\n          stop(\"The index for the indicator in uvar is out of range.\")\n        }\n        ridx[r] = var\n      }\n    }\n  } else {\n    if (is.character(uvar)) {\n      uvar <- tolower(uvar)\n      index <- pmatch(uvar, ulabels, nomatch=0)\n      if (index == 0) {\n        cstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n        stop(cstr)\n      }\n      ridx = index\n    } else {\n      if (uvar <= 0 || uvar > num_r) {\n        stop(\"The index for the indicator (uvar) is out of range.\")\n      }\n      ridx = uvar\n    }\n  }\n  if (group <= 0 || group > props[4]) {\n    stop(\"The group index (group) is out of range.\")\n  }\n  if (missing(covariates)) {\n    xmean <- mplus.get.group.dataset(file,'irt_data','mean')\n    covariates <- xmean[,group]\n  } else {\n    if (length(covariates) != num_fx) {\n      cstr <- sprintf(\"The length of the covariates vector should be %d.\", num_fx)\n      stop(cstr)\n    }\n  }\n\n  categories <- mplus.get.group.attribute(file,'irt_data','categories')\n  if (!(missing(xrange))) {\n    if (xrange <= 0 || xrange > 6) {\n      stop(\"The xrange type should be between 1 and 6.\")\n    }\n  }\n  if (!(missing(xstep))) {\n    if (xstep <= 0 || xstep > 11) {\n      stop(\"The xstep type should be between 1 and 11.\")\n    }\n  }\n\n  variances <- mplus.get.group.dataset(file,'irt_data','variance')\n  means <- mplus.get.group.dataset(file,'irt_data','mean')\n  fsd = sqrt(variances[fidx])\n\n  xmult <- switch(xrange, 1, 2, 3, 4, 5, 6)\n  vmin = means[fidx] + (-1) * xmult * fsd\n  vmax = means[fidx] + xmult * fsd\n\n  vstep = switch(xstep, 1.0, 0.5, 0.1, 0.05, 0.5*fsd, 0.25*fsd, 0.2*fsd, 0.1*fsd, 0.05*fsd, 0.02*fsd, 0.01*fsd)\n  steps <- seq(vmin,vmax,by=vstep)\n\n  # if cat is missing, then we plot all categories\n  if (missing(uvar)) {\n    prob <- array(0,c(num_r,length(steps)))\n    xx <- array(0,c(num_r,length(steps)))\n    for (r in c(1:num_r)) {\n      prob[r,] <- mplus.compute.irt.iic(file,group,fidx,r,xvector=steps,covariates=covariates)\n      xx[r,] <- steps\n    }\n\n    # plot the iic\n    cstr <- sprintf(\"Item information curves as a function of %s, Class %d\", flabels[fidx], group)\n    colors <- rainbow(num_r)\n    plot(xx,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n    for (i in c(1:num_r)) {\n      lines(xx[i,],prob[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(num_r))\n    lty <- array(0,c(num_r))\n    lwd <- array(0,c(num_r))\n    for (i in c(1:num_r)) {\n      ldesc[i] <- sprintf(\"%s\", ulabels[i])\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(lloc,ldesc,col=colors,lty=lty,lwd=lwd)\n  } else if (length(ridx) > 1) {\n    prob <- array(0,c(length(ridx),length(steps)))\n    xx <- array(0,c(length(ridx),length(steps)))\n    for (r in c(1:length(ridx))) {\n      prob[r,] <- mplus.compute.irt.iic(file,group,fidx,ridx[r],xvector=steps,covariates=covariates)\n      xx[r,] <- steps\n    }\n\n    # plot the iic\n    cstr <- sprintf(\"Item information curves as a function of %s, Class %d\", flabels[fidx], group)\n    colors <- rainbow(length(ridx))\n    plot(xx,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n    for (i in c(1:length(ridx))) {\n      lines(xx[i,],prob[i,],col=colors[i])\n    }\n\n    #\t\tfor (i in c(1:length(steps))) {\n    #\t\t\tcstr <- sprintf(\"x = %0.3f, probx = %0.3f\", xx[1,i], prob[1,i])\n    #\t\t\tprint(cstr)\n    #\t\t}\n\n    ldesc <- array(0,c(length(ridx)))\n    lty <- array(0,c(length(ridx)))\n    lwd <- array(0,c(length(ridx)))\n    for (i in c(1:length(ridx))) {\n      ldesc[i] <- sprintf(\"%s\", ulabels[ridx[i]])\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(lloc,ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    prob <- mplus.compute.irt.iic(file,group,fidx,ridx,steps,covariates)\n\n    #\t\tfor (i in c(1:length(steps))) {\n    #\t\t\tcstr <- sprintf(\"x = %0.3f, probx = %0.3f\", steps[i], prob[i])\n    #\t\t\tprint(cstr)\n    #\t\t}\n\n    # plot the iic\n    cstr <- sprintf(\"Item information curve for %s as a function of %s, Class %d\", ulabels[ridx], flabels[fidx], group)\n    plot(steps,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n    lines(steps,prob,col='red')\n  }\n}\n\n\n#========================================================================\n# mplus.plot.irt.tic\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file (required)\n#\tgroup - the group number (not required)\n#\t\t - if not given, group=1 will be shown\n#\txvar - the variable for the x-axis, can be the variable index or quoted variable name (not required, uses the first x)\n#\tuvar - the indicator variable or vector containing more than one indicator variable\n#\t\t - can be the variable index or the quoted variable name\n#\t\t - if not given, assume all indicator variables (not required)\n#\tcovariates -> the vector containing values for all the other covariates (not required, sample mean used if not given)\n#\txrange - the type of range for the x-axis (not required)\n#\t\t- xrange=1: -1 s.d to +1 s.d of xvar\n#\t\t- xrange=2: -2 s.d to +2 s.d of xvar\n#\t\t- xrange=3: -3 s.d to +3 s.d of xvar (default)\n#\t\t- xrange=4: -4 s.d to +4 s.d of xvar\n#\t\t- xrange=5: -5 s.d to +5 s.d of xvar\n#\t\t- xrange=6: -6 s.d to +6 s.d of xvar\n#\txstep - the step increment for the x-axis range (not required)\n#\t\t- xstep=1: 1.0\n#\t\t- xstep=2: 0.5\n#\t\t- xstep=3: 0.1\n#\t\t- xstep=4: 0.05\n#\t\t- xstep=5: 1/2 s.d of xvar\n#\t\t- xstep=6: 1/4 s.d of xvar\n#\t\t- xstep=7: 1/5 s.d of xvar (default)\n#\t\t- xstep=8: 1/10 s.d of xvar\n#\t\t- xstep=9: 1/20 s.d of xvar\n#\t\t- xstep=10: 1/50 s.d of xvar\n#\t\t- xstep=11: 1/100 s.d of xvar\n#\n# eg. mplus.plot.irt.tic('ex7.27.gh5',1,'F','U1',)\n#\nmplus.plot.irt.tic <- function(file,group=1,xvar=1,uvar,covariates,xrange=3,xstep=7) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if irt data exists\n  if ( !(\"irt_data\" %in% names(gh5)) ) {\n    stop(\"This function requires IRT data.\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  #\tproperties[1] - number of factors\n  #\tproperties[2] - number of factors/covariates\n  #\tproperties[3] - number of indicators\n  #\tproperties[4] - number of classes\n  #\tproperties[5] - maximum number of categories\n  props <- mplus.get.group.attribute(file,'irt_data','properties')\n\n  flabels <- mplus.get.group.attribute(file,'irt_data','flabels')\n  flabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", flabels, perl=TRUE)\n  flabels <- tolower(flabels)\n  ulabels <- mplus.get.group.attribute(file,'irt_data','ulabels')\n  ulabels <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", ulabels, perl=TRUE)\n  ulabels <- tolower(ulabels)\n\n  num_fx <- as.integer(props[2])\n  num_r <- as.integer(props[3])\n  max_num_cat <- as.integer(props[5])\n\n  if (is.character(xvar)) {\n    index <- pmatch(xvar, flabels, nomatch=0)\n    if (index == 0) {\n      cstr <- sprintf(\"Unknown variable for the x-axis:  %s\\n\", xvar)\n      stop(cstr)\n    }\n    fidx = index\n  } else {\n    if (xvar <= 0 || xvar > num_fx) {\n      stop(\"The index for the x-variable (xvar) is out of range.\")\n    }\n    fidx = xvar\n  }\n  if (missing(uvar)) {\n  } else if (length(uvar) > 1) {\n    ridx <- vector()\n    for (r in c(1:length(uvar))) {\n      var <- uvar[r]\n      if (is.character(var)) {\n        index <- pmatch(var, ulabels, nomatch=0)\n        if (index == 0) {\n          cstr <- sprintf(\"Unknown indicator:  %s\\n\", var)\n          stop(cstr)\n        }\n        ridx[r] = index\n      } else {\n        if (var <= 0 || var > num_r) {\n          stop(\"The index for the indicator in uvar is out of range.\")\n        }\n        ridx[r] = var\n      }\n    }\n  } else {\n    if (is.character(uvar)) {\n      index <- pmatch(uvar, ulabels, nomatch=0)\n      if (index == 0) {\n        cstr <- sprintf(\"Unknown indicator:  %s\\n\", uvar)\n        stop(cstr)\n      }\n      ridx = index\n    } else {\n      if (uvar <= 0 || uvar > num_r) {\n        stop(\"The index for the indicator (uvar) is out of range.\")\n      }\n      ridx = uvar\n    }\n  }\n  if (group <= 0 || group > props[4]) {\n    stop(\"The group index (group) is out of range.\")\n  }\n  if (missing(covariates)) {\n    xmean <- mplus.get.group.dataset(file,'irt_data','mean')\n    covariates <- xmean[,group]\n  } else {\n    if (length(covariates) != num_fx) {\n      cstr <- sprintf(\"The length of the covariates vector should be %d.\", num_fx)\n      stop(cstr)\n    }\n  }\n\n  categories <- mplus.get.group.attribute(file,'irt_data','categories')\n  if (!(missing(xrange))) {\n    if (xrange <= 0 || xrange > 6) {\n      stop(\"The xrange type should be between 1 and 6.\")\n    }\n  }\n  if (!(missing(xstep))) {\n    if (xstep <= 0 || xstep > 11) {\n      stop(\"The xstep type should be between 1 and 11.\")\n    }\n  }\n\n  variances <- mplus.get.group.dataset(file,'irt_data','variance')\n  means <- mplus.get.group.dataset(file,'irt_data','mean')\n  fsd = sqrt(variances[fidx])\n\n  xmult <- switch(xrange, 1, 2, 3, 4, 5, 6)\n  vmin = means[fidx] + (-1) * xmult * fsd\n  vmax = means[fidx] + xmult * fsd\n\n  vstep = switch(xstep, 1.0, 0.5, 0.1, 0.05, 0.5*fsd, 0.25*fsd, 0.2*fsd, 0.1*fsd, 0.05*fsd, 0.02*fsd, 0.01*fsd)\n  steps <- seq(vmin,vmax,by=vstep)\n\n  # if cat is missing, then we plot all categories\n  if (missing(uvar)) {\n    prob <- array(0,c(length(steps)))\n    for (r in c(1:num_r)) {\n      prob <- prob + mplus.compute.irt.iic(file,group,fidx,r,xvector=steps,covariates=covariates)\n    }\n    prob <- prob + 1 / gh5$irt_data$variance[fidx,group]\n    # plot the tic\n    cstr <- sprintf(\"Total information curve as a function of %s, Class %d\", flabels[fidx], group)\n    plot(steps,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n    lines(steps,prob,col='red')\n  } else if (length(ridx) > 1) {\n    prob <- array(0,c(length(steps)))\n    for (r in c(1:length(ridx))) {\n      prob <- prob + mplus.compute.irt.iic(file,group,fidx,ridx[r],xvector=steps,covariates=covariates)\n    }\n\n    # plot the iic\n    cstr <- sprintf(\"Partial total information curve as a function of %s, Class %d\", flabels[fidx], group)\n    plot(steps,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n    lines(steps,prob,col='red')\n  } else {\n    prob <- mplus.compute.irt.iic(file,group,fidx,ridx,steps,covariates)\n\n    # plot the tic\n    cstr <- sprintf(\"Partial total information curve as a function of %s, Class %d\", flabels[fidx], group)\n    plot(steps,prob,xlab=flabels[fidx],ylab=\"Information\",main=cstr,type='n')\n    lines(steps,prob,col='red')\n  }\n\n  #\tfor (i in c(1:length(steps))) {\n  #\t\tcstr <- sprintf(\"x = %0.3f, probx = %0.5f\", steps[i], prob[i])\n  #\t\tprint(cstr)\n  #\t}\n}\n\n\n\n######################################################################################################\n# Functions for Survival plots\n######################################################################################################\n\n#========================================================================\n# mplus.list.survival.variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.survival.variables('ex6.21.gh5')\n#\nmplus.list.survival.variables <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  #\tcat(c(\"\\nList of variables to use in the following functions:\\n\"))\n  #\tcat(c(\" - mplus.compute.irt.icc\\n\"))\n  #\tcat(c(\" - mplus.plot.irt.icc\\n\"))\n\n  cat(c(\"\\nList of survival variables:\\n\"))\n\n  for (i in c(1:props[1])) {\n    cstr <- sprintf(\"survival_data/survival%d\", i)\n    label <- mplus.get.group.attribute(file,cstr,'label')\n    cstr <- sprintf(\"%s\", label)\n    cstr <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", cstr, perl=TRUE)\n    print(cstr)\n  }\n}\n\n\n#========================================================================\n# mplus.get.survival.kaplanmeier.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.survival.kaplanmeier.values('ex6.21.gh5','T')\n#\nmplus.get.survival.kaplanmeier.values <- function(file,survvar,classnum,time) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  if (missing(survvar)) {\n    stop(\"The survival variable must be given.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  if (missing(classnum)) {\n    datastr <- sprintf(\"kaplan_meier1\")\n  } else {\n    classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n    dims <- attr(classes,'dim')\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n    datastr <- sprintf(\"kaplan_meier%d\", classnum)\n  }\n  kmvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n  if (missing(time)) {\n    return(kmvals[,2])\n  } else {\n    return(kmvals[,1])\n  }\n}\n\n\n\n#========================================================================\n# mplus.compute.survival.sample.logcumulative.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.compute.survival.sample.logcumulative.values('ex6.21.gh5','T')\n#\nmplus.compute.survival.sample.logcumulative.values <- function(file,survvar,classnum,time) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  if (missing(survvar)) {\n    stop(\"The survival variable must be given.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  if (missing(classnum)) {\n    datastr <- sprintf(\"kaplan_meier1\")\n  } else {\n    classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n    dims <- attr(classes,'dim')\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n    datastr <- sprintf(\"kaplan_meier%d\", classnum)\n  }\n  kmvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n  y <- log(-log(kmvals[,2]))\n  return(y)\n}\n\n\n#========================================================================\n# mplus.get.survival.baseline.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tsurvvar2 - ending survival variable for getting sequential time\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.survival.baseline.values('ex6.21.gh5','T')\n#\nmplus.get.survival.baseline.values <- function(file,survvar,survvar2,classnum,time) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  if (missing(survvar)) {\n    stop(\"The survival variable must be given.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  if (!(missing(survvar2))) {\n    if (is.character(survvar2)) {\n      surv_idx2 <- 0\n      for (i in c(1:props[1])) {\n        cstr <- sprintf(\"survival_data/survival%d\", i)\n        label <- mplus.get.group.attribute(file,cstr,'label')\n        label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n        if (label == survvar2) {\n          surv_idx2 = i\n          break\n        }\n      }\n      if (surv_idx2 == 0) {\n        stop(\"- unknown survival variable:  \", survvar2)\n      }\n    } else {\n      if (survvar2 <= 0 || survvar2 > props[1]) {\n        stop(\"- index for the survival variable is out of range\")\n      }\n      surv_idx2 = survvar2\n    }\n  }\n\n  if (missing(survvar2)) {\n    groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n    if (missing(classnum)) {\n      datastr <- sprintf(\"estimated_survival\")\n    } else {\n      classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n      dims <- attr(classes,'dim')\n      if (classnum <= 0 || classnum > dims[1]) {\n        stop(\"Class number is out of range.\")\n      }\n      datastr <- sprintf(\"estimated_survival%d\", classnum)\n    }\n    esvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n    if (missing(time)) {\n      return(esvals[,2])\n    } else {\n      return(esvals[,1])\n    }\n  } else {\n    # ending survival variable given so we need to link them sequentially\n    ylast <- 1\n    xlast <- 0\n    data <- vector()\n    time <- vector()\n    count <- 0\n    for (s in c(surv_idx:surv_idx2)) {\n      groupstr <- sprintf(\"survival_data/survival%d\", s)\n      if (missing(classnum)) {\n        datastr <- sprintf(\"estimated_survival\")\n      } else {\n        classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n        dims <- attr(classes,'dim')\n        if (classnum <= 0 || classnum > dims[1]) {\n          stop(\"Class number is out of range.\")\n        }\n        datastr <- sprintf(\"estimated_survival%d\", classnum)\n      }\n      esvals1 <- mplus.get.group.dataset(file,groupstr,datastr)\n\n      if (s == surv_idx) {\n        count <- length(esvals1[,1])\n        data[1:count] <- esvals1[,1]\n        time[1:count] <- estvals[,2]\n      } else {\n        n <- length(estvals1[,1])\n      }\n    }\n  }\n}\n\n\n\n#========================================================================\n# mplus.compute.survival.estimated.logcumulative.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.compute.survival.estimated.logcumulative.values('ex6.21.gh5','T')\n#\nmplus.compute.survival.estimated.logcumulative.values <- function(file,survvar,classnum,time) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  if (missing(survvar)) {\n    stop(\"The survival variable must be given.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  if (missing(classnum)) {\n    datastr <- sprintf(\"estimated_survival1\")\n  } else {\n    classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n    dims <- attr(classes,'dim')\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n    datastr <- sprintf(\"estimated_survival%d\", classnum)\n  }\n  esvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n  y <- log(-log(esvals[,2]))\n  return(y)\n}\n\n\n\n#========================================================================\n# mplus.get.survival.basehazard.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.survival.basehazard.values('ex6.21.gh5','T')\n#\nmplus.get.survival.basehazard.values <- function(file,survvar,classnum,time) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  if (missing(survvar)) {\n    stop(\"The survival variable must be given.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  if (missing(classnum)) {\n    datastr <- sprintf(\"basehazard\")\n  } else {\n    classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n    dims <- attr(classes,'dim')\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n    datastr <- sprintf(\"basehazard%d\", classnum)\n  }\n  bhvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n  if (missing(time)) {\n    return(bhvals[,2])\n  } else {\n    return(bhvals[,1])\n  }\n}\n\n\n#========================================================================\n# mplus.plot.survival.kaplanmeier\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.kaplanmeier('ex6.21.gh5','T')\n#\nmplus.plot.survival.kaplanmeier <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Kaplan-Meier curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n      npoints[i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(dims[1],maxpoints))\n    yall <- array(NA, c(dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[i,1:npoints[i]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n      yall[i,1:npoints[i]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i)\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(dims[1])\n    for (i in c(1:dims[1])) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(dims[1]))\n    lty <- array(0,c(dims[1]))\n    lwd <- array(0,c(dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[i] <- sprintf(\"Class %d\", i)\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"- class number is out of range\")\n    }\n\n    xx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n    yy <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum)\n\n    plot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n    lines(xx,yy,col='red')\n  }\n}\n\n\n\n#========================================================================\n# mplus.plot.survival.baseline\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.baseline('ex6.21.gh5','T')\n#\nmplus.plot.survival.baseline <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Estimated baseline survival curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      npoints[i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(dims[1],maxpoints))\n    yall <- array(NA, c(dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[i,1:npoints[i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      yall[i,1:npoints[i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i)\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(dims[1])\n    for (i in c(1:dims[1])) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(dims[1]))\n    lty <- array(0,c(dims[1]))\n    lwd <- array(0,c(dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[i] <- sprintf(\"Class %d\", i)\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n\n    xx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n    yy <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum)\n\n    plot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n    lines(xx,yy,col='red')\n  }\n}\n\n\n#========================================================================\n# mplus.plot.survival.basehazard\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.basehazard('ex6.21.gh5','T')\n#\nmplus.plot.survival.basehazard <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required.\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Estimated baseline hazard curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.survival.basehazard.values(file,surv_idx,i,0)\n      npoints[i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(dims[1],maxpoints))\n    yall <- array(NA, c(dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[i,1:npoints[i]] <- mplus.get.survival.basehazard.values(file,surv_idx,i,0)\n      yall[i,1:npoints[i]] <- mplus.get.survival.basehazard.values(file,surv_idx,i)\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"\",main=cstr,type='n')\n\n    colors <- rainbow(dims[1])\n    for (i in c(1:dims[1])) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(dims[1]))\n    lty <- array(0,c(dims[1]))\n    lwd <- array(0,c(dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[i] <- sprintf(\"Class %d\", i)\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n\n    xx <- mplus.get.survival.basehazard.values(file,surv_idx,classnum,0)\n    yy <- mplus.get.survival.basehazard.values(file,surv_idx,classnum)\n\n    plot(xx,yy,xlab=\"Time\",ylab=\"\",main=cstr,type='n')\n    lines(xx,yy,col='red')\n  }\n}\n\n\n#========================================================================\n# mplus.plot.survival.sample.logcumulative\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.sample.logcumulative('ex6.21.gh5','T')\n#\nmplus.plot.survival.sample.logcumulative <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Sample log cumulative hazard curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n      npoints[i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(dims[1],maxpoints))\n    yall <- array(NA, c(dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[i,1:npoints[i]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n      yall[i,1:npoints[i]] <- mplus.compute.survival.sample.logcumulative.values(file,surv_idx,i)\n      for (j in c(1:npoints[i])) {\n        if (is.infinite(yall[j])) {\n          xall[j] = NA\n        }\n      }\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(dims[1])\n    for (i in c(1:dims[1])) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(dims[1]))\n    lty <- array(0,c(dims[1]))\n    lwd <- array(0,c(dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[i] <- sprintf(\"Class %d\", i)\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n\n    xx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n    yy <- mplus.compute.survival.sample.logcumulative.values(file,surv_idx,classnum)\n    for (j in c(1:length(xx))) {\n      if (is.infinite(yy[j])) {\n        xx[j] = NA\n      }\n    }\n\n    plot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n    lines(xx,yy,col='red')\n  }\n}\n\n\n\n#========================================================================\n# mplus.plot.survival.estimated.logcumulative\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.estimated.logcumulative('ex6.21.gh5','T')\n#\nmplus.plot.survival.estimated.logcumulative <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Estimated log cumulative hazard curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      npoints[i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(dims[1],maxpoints))\n    yall <- array(NA, c(dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[i,1:npoints[i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      yall[i,1:npoints[i]] <- mplus.compute.survival.estimated.logcumulative.values(file,surv_idx,i)\n      for (j in c(1:npoints[i])) {\n        if (is.infinite(yall[j])) {\n          xall[j] = NA\n        }\n      }\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(dims[1])\n    for (i in c(1:dims[1])) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(dims[1]))\n    lty <- array(0,c(dims[1]))\n    lwd <- array(0,c(dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[i] <- sprintf(\"Class %d\", i)\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n\n    xx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n    yy <- mplus.compute.survival.estimated.logcumulative.values(file,surv_idx,classnum)\n    for (j in c(1:length(xx))) {\n      if (is.infinite(yy[j])) {\n        xx[j] = NA\n      }\n    }\n\n    plot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n    lines(xx,yy,col='red')\n  }\n}\n\n\n\n#========================================================================\n# mplus.plot.survival.kaplanmeier.vs.baseline\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.kaplanmeier.vs.baseline('ex6.21.gh5','T')\n#\nmplus.plot.survival.kaplanmeier.vs.baseline <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Kaplan-Meier curve compared with\\nestimated baseline survival curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(2*dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n      npoints[2*(i-1)+1] = length(xx)\n      xx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      npoints[2*i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(2*dims[1],maxpoints))\n    yall <- array(NA, c(2*dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n      yall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i)\n\n      xall[2*i,1:npoints[2*i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      yall[2*i,1:npoints[2*i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i)\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(2*dims[1])\n    for (i in c(1:(2*dims[1]))) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(2*dims[1]))\n    lty <- array(0,c(2*dims[1]))\n    lwd <- array(0,c(2*dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[2*(i-1)+1] <- sprintf(\"KM for Class %d\", i)\n      lty[2*(i-1)+1] = 1\n      lwd[2*(i-1)+1] = 2.5\n\n      ldesc[2*i] <- sprintf(\"ES for Class %d\", i)\n      lty[2*i] = 1\n      lwd[2*i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n\n    npoints <- array(0, c(2))\n    xx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n    npoints[1] = length(xx)\n    xx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n    npoints[2] = length(xx)\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(2,maxpoints))\n    yall <- array(NA, c(2,maxpoints))\n\n    xall[1,1:npoints[1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n    yall[1,1:npoints[1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum)\n\n    xall[2,1:npoints[2]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n    yall[2,1:npoints[2]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum)\n\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(2)\n    for (i in c(1:2)) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(2))\n    lty <- array(0,c(2))\n    lwd <- array(0,c(2))\n\n    ldesc[1] <- sprintf(\"KM for Class %d\", classnum)\n    lty[1] = 1\n    lwd[1] = 2.5\n\n    ldesc[2] <- sprintf(\"ES for Class %d\", classnum)\n    lty[2] = 1\n    lwd[2] = 2.5\n\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  }\n}\n\n\n\n#========================================================================\n# mplus.plot.survival.sample.vs.estimated.logcumulative\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.survival.sample.vs.estimated.logcumulative('ex6.21.gh5','T')\n#\nmplus.plot.survival.sample.vs.estimated.logcumulative <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Sample log cumulative hazard curve compared with\\nestimated log cumulative baseline hazard curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(2*dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n      npoints[2*(i-1)+1] = length(xx)\n      xx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      npoints[2*i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(2*dims[1],maxpoints))\n    yall <- array(NA, c(2*dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,i,0)\n      yall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.compute.survival.sample.logcumulative.values(file,surv_idx,i)\n\n      xall[2*i,1:npoints[2*i]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      yall[2*i,1:npoints[2*i]] <- mplus.compute.survival.estimated.logcumulative.values(file,surv_idx,i)\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(2*dims[1])\n    for (i in c(1:(2*dims[1]))) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(2*dims[1]))\n    lty <- array(0,c(2*dims[1]))\n    lwd <- array(0,c(2*dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[2*(i-1)+1] <- sprintf(\"LC for Class %d\", i)\n      lty[2*(i-1)+1] = 1\n      lwd[2*(i-1)+1] = 2.5\n\n      ldesc[2*i] <- sprintf(\"ELC for Class %d\", i)\n      lty[2*i] = 1\n      lwd[2*i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n\n    npoints <- array(0, c(2))\n    xx <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n    npoints[1] = length(xx)\n    xx <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n    npoints[2] = length(xx)\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(2,maxpoints))\n    yall <- array(NA, c(2,maxpoints))\n\n    xall[1,1:npoints[1]] <- mplus.get.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n    yall[1,1:npoints[1]] <-mplus.compute.survival.sample.logcumulative.values(file,surv_idx,classnum)\n\n    xall[2,1:npoints[2]] <- mplus.get.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n    yall[2,1:npoints[2]] <- mplus.compute.survival.estimated.logcumulative.values(file,surv_idx,classnum)\n\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(2)\n    for (i in c(1:2)) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(2))\n    lty <- array(0,c(2))\n    lwd <- array(0,c(2))\n\n    ldesc[1] <- sprintf(\"LC for Class %d\", classnum)\n    lty[1] = 1\n    lwd[1] = 2.5\n\n    ldesc[2] <- sprintf(\"ELC for Class %d\", classnum)\n    lty[2] = 1\n    lwd[2] = 2.5\n\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  }\n}\n\n\n\n\n######################################################################################################\n# Functions for Discrete survival plots\n######################################################################################################\n\n#========================================================================\n# mplus.list.discrete.survival.variables\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\n# eg. mplus.list.discrete.survival.variables('ex6.21.gh5')\n#\nmplus.list.discrete.survival.variables <- function(file) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n    stop(\"- discrete survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n  #\tcat(c(\"\\nList of variables to use in the following functions:\\n\"))\n  #\tcat(c(\" - mplus.compute.irt.icc\\n\"))\n  #\tcat(c(\" - mplus.plot.irt.icc\\n\"))\n\n  cat(c(\"\\nList of survival variables:\\n\"))\n\n  for (i in c(1:props[1])) {\n    cstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n    label <- mplus.get.group.attribute(file,cstr,'label')\n    cstr <- sprintf(\"%s\", label)\n    cstr <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", cstr, perl=TRUE)\n    print(cstr)\n  }\n}\n\n\n#========================================================================\n# mplus.get.discrete.survival.kaplanmeier.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.discrete.survival.kaplanmeier.values('ex6.21.gh5','T')\n#\nmplus.get.discrete.survival.kaplanmeier.values <- function(file,survvar,classnum,time) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  if (missing(survvar)) {\n    stop(\"The survival variable must be given.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n  if (missing(classnum)) {\n    datastr <- sprintf(\"kaplan_meier1\")\n  } else {\n    classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n    dims <- attr(classes,'dim')\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n    datastr <- sprintf(\"kaplan_meier%d\", classnum)\n  }\n  kmvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n  if (missing(time)) {\n    return(kmvals[,2])\n  } else {\n    return(kmvals[,1])\n  }\n}\n\n#========================================================================\n# mplus.get.discrete.survival.baseline.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tsurvvar2 - ending survival variable for getting sequential time\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.discrete.survival.baseline.values('ex6.21.gh5','T')\n#\nmplus.get.discrete.survival.baseline.values <- function(file,survvar,survvar2,classnum,time) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  if (missing(survvar)) {\n    stop(\"The survival variable must be given.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  if (!(missing(survvar2))) {\n    if (is.character(survvar2)) {\n      surv_idx2 <- 0\n      for (i in c(1:props[1])) {\n        cstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n        label <- mplus.get.group.attribute(file,cstr,'label')\n        label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n        if (label == survvar2) {\n          surv_idx2 = i\n          break\n        }\n      }\n      if (surv_idx2 == 0) {\n        stop(\"- unknown survival variable:  \", survvar2)\n      }\n    } else {\n      if (survvar2 <= 0 || survvar2 > props[1]) {\n        stop(\"- index for the survival variable is out of range\")\n      }\n      surv_idx2 = survvar2\n    }\n  }\n\n  if (missing(survvar2)) {\n    groupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n    if (missing(classnum)) {\n      datastr <- sprintf(\"estimated_survival\")\n    } else {\n      classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n      dims <- attr(classes,'dim')\n      if (classnum <= 0 || classnum > dims[1]) {\n        stop(\"Class number is out of range.\")\n      }\n      datastr <- sprintf(\"estimated_survival%d\", classnum)\n    }\n    esvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n    if (missing(time)) {\n      return(esvals[,2])\n    } else {\n      return(esvals[,1])\n    }\n  } else {\n    # ending survival variable given so we need to link them sequentially\n    ylast <- 1\n    xlast <- 0\n    data <- vector()\n    time <- vector()\n    count <- 0\n    for (s in c(surv_idx:surv_idx2)) {\n      groupstr <- sprintf(\"discrete_survival_data/survival%d\", s)\n      if (missing(classnum)) {\n        datastr <- sprintf(\"estimated_survival\")\n      } else {\n        classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n        dims <- attr(classes,'dim')\n        if (classnum <= 0 || classnum > dims[1]) {\n          stop(\"Class number is out of range.\")\n        }\n        datastr <- sprintf(\"estimated_survival%d\", classnum)\n      }\n      esvals1 <- mplus.get.group.dataset(file,groupstr,datastr)\n\n      if (s == surv_idx) {\n        count <- length(esvals1[,1])\n        data[1:count] <- esvals1[,1]\n        time[1:count] <- estvals[,2]\n      } else {\n        n <- length(estvals1[,1])\n      }\n    }\n  }\n}\n\n\n\n#========================================================================\n# mplus.get.discrete.survival.basehazard.values\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.get.discrete.survival.basehazard.values('ex6.21.gh5','T')\n#\nmplus.get.discrete.survival.basehazard.values <- function(file,survvar,classnum,time) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  if (missing(survvar)) {\n    stop(\"The survival variable must be given.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n  if (missing(classnum)) {\n    datastr <- sprintf(\"basehazard\")\n  } else {\n    classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n    dims <- attr(classes,'dim')\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n    datastr <- sprintf(\"basehazard%d\", classnum)\n  }\n  bhvals <- mplus.get.group.dataset(file,groupstr,datastr)\n\n  if (missing(time)) {\n    return(bhvals[,2])\n  } else {\n    return(bhvals[,1])\n  }\n}\n\n\n#========================================================================\n# mplus.plot.discrete.survival.kaplanmeier\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.discrete.survival.kaplanmeier('ex6.21.gh5','T')\n#\nmplus.plot.discrete.survival.kaplanmeier <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Kaplan-Meier curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i,0)\n      npoints[i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(dims[1],maxpoints))\n    yall <- array(NA, c(dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[i,1:npoints[i]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i,0)\n      yall[i,1:npoints[i]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i)\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(dims[1])\n    for (i in c(1:dims[1])) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(dims[1]))\n    lty <- array(0,c(dims[1]))\n    lwd <- array(0,c(dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[i] <- sprintf(\"Class %d\", i)\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"- class number is out of range\")\n    }\n\n    xx <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n    yy <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum)\n\n    plot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n    lines(xx,yy,col='red')\n  }\n}\n\n\n\n#========================================================================\n# mplus.plot.discrete.survival.baseline\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.discrete.survival.baseline('ex6.21.gh5','T')\n#\nmplus.plot.discrete.survival.baseline <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Estimated baseline survival curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      npoints[i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(dims[1],maxpoints))\n    yall <- array(NA, c(dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[i,1:npoints[i]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      yall[i,1:npoints[i]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i)\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n\n    colors <- rainbow(dims[1])\n    for (i in c(1:dims[1])) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(dims[1]))\n    lty <- array(0,c(dims[1]))\n    lwd <- array(0,c(dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[i] <- sprintf(\"Class %d\", i)\n      lty[i] = 1\n      lwd[i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n\n    xx <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n    yy <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum)\n\n    plot(xx,yy,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n',ylim=c(0,1))\n    lines(xx,yy,col='red')\n  }\n}\n\n\n#========================================================================\n# mplus.plot.discrete.survival.kaplanmeier.vs.baseline\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#\tsurvvar - the quoted name of the survival variable or the index of the survival variable (not required)\n#\tclassnum - the group number (not required)\n#\n# eg. mplus.plot.discrete.survival.kaplanmeier.vs.baseline('ex6.21.gh5','T')\n#\nmplus.plot.discrete.survival.kaplanmeier.vs.baseline <- function(file,survvar=1,classnum) {\n  if (missing(file)) {\n    stop(\"- name of the GH5 file is required\")\n  }\n  if (!(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  # check if survival data exists\n  if ( !(\"discrete_survival_data\" %in% names(gh5)) ) {\n    stop(\"- survival data is required\\n\\nUse TYPE=PLOT2.\")\n  }\n\n  props <- mplus.get.group.attribute(file,'discrete_survival_data','properties')\n\n  if (is.character(survvar)) {\n    surv_idx <- 0\n    for (i in c(1:props[1])) {\n      cstr <- sprintf(\"discrete_survival_data/survival%d\", i)\n      label <- mplus.get.group.attribute(file,cstr,'label')\n      label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n      if (label == survvar) {\n        surv_idx = i\n        break\n      }\n    }\n    if (surv_idx == 0) {\n      stop(\"- unknown survival variable:  \", survvar)\n    }\n  } else {\n    if (survvar <= 0 || survvar > props[1]) {\n      stop(\"- index for the survival variable is out of range\")\n    }\n    surv_idx = survvar\n  }\n\n  groupstr <- sprintf(\"discrete_survival_data/survival%d\", surv_idx)\n  label <- mplus.get.group.attribute(file,groupstr,'label')\n  label <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", label, perl=TRUE)\n\n  classes <- mplus.get.group.dataset(file,'/','model_group_labels')\n  dims <- attr(classes,'dim')\n\n  cstr <- sprintf(\"Kaplan-Meier curve compared with\\nestimated baseline survival curve for %s\", label)\n\n  if (missing(classnum)) {\n    npoints <- array(0, c(2*dims[1]))\n    for (i in c(1:dims[1])) {\n      xx <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i,0)\n      npoints[2*(i-1)+1] = length(xx)\n      xx <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      npoints[2*i] = length(xx)\n    }\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(2*dims[1],maxpoints))\n    yall <- array(NA, c(2*dims[1],maxpoints))\n\n    for (i in c(1:dims[1])) {\n      xall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i,0)\n      yall[2*(i-1)+1,1:npoints[2*(i-1)+1]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,i)\n\n      xall[2*i,1:npoints[2*i]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i,time=0)\n      yall[2*i,1:npoints[2*i]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=i)\n    }\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n')\n\n    colors <- rainbow(2*dims[1])\n    for (i in c(1:(2*dims[1]))) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(2*dims[1]))\n    lty <- array(0,c(2*dims[1]))\n    lwd <- array(0,c(2*dims[1]))\n    for (i in c(1:dims[1])) {\n      ldesc[2*(i-1)+1] <- sprintf(\"KM for Class %d\", i)\n      lty[2*(i-1)+1] = 1\n      lwd[2*(i-1)+1] = 2.5\n\n      ldesc[2*i] <- sprintf(\"ES for Class %d\", i)\n      lty[2*i] = 1\n      lwd[2*i] = 2.5\n    }\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  } else {\n    if (classnum <= 0 || classnum > dims[1]) {\n      stop(\"Class number is out of range.\")\n    }\n\n    npoints <- array(0, c(2))\n    xx <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n    npoints[1] = length(xx)\n    xx <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n    npoints[2] = length(xx)\n    maxpoints = max(npoints)\n\n    xall <- array(NA, c(2,maxpoints))\n    yall <- array(NA, c(2,maxpoints))\n\n    xall[1,1:npoints[1]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum,0)\n    yall[1,1:npoints[1]] <- mplus.get.discrete.survival.kaplanmeier.values(file,surv_idx,classnum)\n\n    xall[2,1:npoints[2]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum,time=0)\n    yall[2,1:npoints[2]] <- mplus.get.discrete.survival.baseline.values(file,surv_idx,classnum=classnum)\n\n    plot(xall,yall,xlab=\"Time\",ylab=\"Probability\",main=cstr,type='n')\n\n    colors <- rainbow(2)\n    for (i in c(1:2)) {\n      lines(xall[i,],yall[i,],col=colors[i])\n    }\n\n    ldesc <- array(0,c(2))\n    lty <- array(0,c(2))\n    lwd <- array(0,c(2))\n\n    ldesc[1] <- sprintf(\"KM for Class %d\", classnum)\n    lty[1] = 1\n    lwd[1] = 2.5\n\n    ldesc[2] <- sprintf(\"ES for Class %d\", classnum)\n    lty[2] = 1\n    lwd[2] = 2.5\n\n    legend(\"top\",ldesc,col=colors,lty=lty,lwd=lwd)\n  }\n}\n\n\n\n\n\n######################################################################################################\n# Supporting functions\n######################################################################################################\n\n\n##########################################################################\n#\n# mplus.get.group.attribute - supporting function for getting attribute\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   groupstr - the name of the group for the attribute\n#   attrstr - the name of the attribute\n#\n# eg. mplus.get.attribute('ex8.1.gh5','individual_data','var_names')\n#\nmplus.get.group.attribute <- function(file, groupstr, attrstr) {\n  if ( !(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  fid <- H5Fopen(file)\n  gid <- H5Gopen(fid, groupstr)\n  atid <- H5Aopen(gid, attrstr)\n\n  attr <- H5Aread(atid)\n\n  H5Aclose(atid)\n  H5Gclose(gid)\n  H5Fclose(fid)\n\n  attr <- gsub(\"(^\\\\s+|\\\\s+$)\", \"\", attr, perl=TRUE)\n\n  return(attr)\n}\n\n##########################################################################\n#\n# mplus.get.group.attribute - supporting function for getting attribute\n#\n# arguments:\n#\tfile - the quoted name of an existing GH5 file\n#   groupstr - the name of the group for the attribute\n#   attrstr - the name of the attribute\n#\n# eg. mplus.get.attribute('ex8.1.gh5','individual_data','var_names')\n#\nmplus.get.dataset.attribute <- function(file, datastr, attrstr) {\n  if ( !(file.exists(file))) {\n    cstr <- paste(\"- file does not exist:\",file,\"\\n\")\n    stop(cstr)\n  }\n\n  gh5 <- h5dump(file, load=TRUE)\n\n  fid <- H5Fopen(file)\n  did <- H5Dopen(fid, datastr)\n  atid <- H5Aopen(did, attrstr)\n\n  attr <- H5Aread(atid)\n\n  H5Aclose(atid)\n  H5Dclose(did)\n  H5Fclose(fid)\n\n  return(attr)\n}\n\n\n\n\n\n\n\n######################################################################################################\n# Math functions\n######################################################################################################\n\nlin <- function(y, link) {\n  if (link == 0) {\n    x <- logistic(y)\n  } else {\n    x <- pnorm(y, mean=0, sd=1)\n  }\n  x\n}\n\nlogistic <- function(y) {\n  if (y > 50) {\n    x = 1\n  } else if (y > -50) {\n    x = 1 / (1 + exp(-y))\n  } else {\n    x = 0\n  }\n\n  x\n}\n\n\n\n",
    "created" : 1445537502024.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2254581769",
    "id" : "9B6CCF69",
    "lastKnownWriteTime" : 1445538723,
    "path" : "~/FOCAL/Rpackages/cpar/R/mplus.R",
    "project_path" : "R/mplus.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}